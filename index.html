<!DOCTYPE html>
<html>
<head>  
<meta name="Author" content="Gerard Ferrandez at http://www.dhteumeuleu.com/">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="HandheldFriendly" content="true">
<meta name="description" content="This is a cool HTML5 technology application where users can draw text or patterns on the canvas with a brush. It will render your drawings in 3D and make them rotate around the center. With clever design, you can create stunning effects and patterns.">
<meta name="keywords" content="canvas,3D,drawing">
<link rel="canonical" href="http://www.webhek.com/misc/circumscrible/">
<link rel="stylesheet" href="static/css/slider.css">
<link rel="shortcut icon" href="/favicon.ico"/>
<title>3D Drawing Studio - Create Your Rotating 3D Name</title>

<!-- Solana Web3.js -->
<script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>

<style>
html {
	overflow: hidden;
	-ms-touch-action: none;
	-ms-content-zooming: none;
}
body {
	position: absolute;
	margin: 0;
	padding: 0;
	background: #1a0b2e;
	width: 100%;
	height: 100%;
	font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
}
#screen {
	position: absolute;
	width: 100%;
	height: 100%;
	cursor: pointer;
}

/* Token Launch Modal Styles */
.modal {
	display: none;
	position: fixed;
	z-index: 10000;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
	background-color: rgba(26, 11, 46, 0.95);
	backdrop-filter: blur(10px);
}

.modal-content {
	background: linear-gradient(135deg, #1a0b2e 0%, #2d1b4e 100%);
	margin: 5% auto;
	padding: 30px;
	border: 2px solid #00ff88;
	border-radius: 20px;
	width: 90%;
	max-width: 500px;
	box-shadow: 0 20px 40px rgba(0, 255, 136, 0.3);
	animation: modalSlideIn 0.3s ease-out;
	position: relative;
	z-index: 10001;
}

@keyframes modalSlideIn {
	from { transform: translateY(-50px); opacity: 0; }
	to { transform: translateY(0); opacity: 1; }
}

.close {
	color: #00ff88;
	float: right;
	font-size: 28px;
	font-weight: bold;
	cursor: pointer;
	transition: color 0.3s;
}

.close:hover {
	color: #7c3aed;
}

.modal h2 {
	color: #00ff88;
	text-align: center;
	margin-bottom: 20px;
	font-size: 24px;
	text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
}

.form-group {
	margin-bottom: 20px;
	position: relative;
	z-index: 10002;
}

.form-group label {
	display: block;
	color: #fff;
	margin-bottom: 8px;
	font-weight: 500;
	position: relative;
	z-index: 10002;
}

.form-group input {
	width: 100%;
	padding: 12px;
	border: 2px solid #444;
	border-radius: 10px;
	background: #2a1f3d;
	color: #fff;
	font-size: 16px;
	font-family: inherit;
	box-sizing: border-box;
	outline: none;
	-webkit-appearance: none;
	-moz-appearance: none;
	appearance: none;
}

.form-group input:focus {
	border-color: #00ff88;
	background: #3a2f4d;
	box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
}

.form-group input::placeholder {
	color: #888;
}

.preview-container {
	text-align: center;
	margin: 20px 0;
}

.preview-image {
	max-width: 200px;
	max-height: 200px;
	border: 2px solid #00ff88;
	border-radius: 10px;
	box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
}

.wallet-section {
	margin: 20px 0;
	padding: 15px;
	border: 2px solid #7c3aed;
	border-radius: 10px;
	background: rgba(124, 58, 237, 0.1);
}

.wallet-status {
	display: flex;
	align-items: center;
	justify-content: space-between;
	margin-bottom: 10px;
}

.wallet-address {
	font-family: monospace;
	font-size: 12px;
	color: #00ff88;
	word-break: break-all;
}

.connect-wallet-btn {
	padding: 10px 20px;
	background: linear-gradient(135deg, #7c3aed 0%, #5b21b6 100%);
	color: white;
	border: none;
	border-radius: 8px;
	font-size: 14px;
	font-weight: bold;
	cursor: pointer;
	transition: all 0.3s;
}

.connect-wallet-btn:hover {
	background: linear-gradient(135deg, #5b21b6 0%, #4c1d95 100%);
	transform: translateY(-2px);
}

.connect-wallet-btn:disabled {
	background: #666;
	cursor: not-allowed;
	transform: none;
}

.launch-btn {
	width: 100%;
	padding: 15px;
	background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
	color: #1a0b2e;
	border: none;
	border-radius: 10px;
	font-size: 18px;
	font-weight: bold;
	cursor: pointer;
	transition: all 0.3s;
	text-transform: uppercase;
	letter-spacing: 1px;
}

.launch-btn:hover {
	background: linear-gradient(135deg, #00cc6a 0%, #00aa55 100%);
	transform: translateY(-2px);
	box-shadow: 0 10px 20px rgba(0, 255, 136, 0.4);
}

.launch-btn:disabled {
	background: #666;
	cursor: not-allowed;
	transform: none;
	box-shadow: none;
}

/* Launch Token Button */
.launch-token-btn {
	position: fixed;
	bottom: 30px;
	right: 30px;
	padding: 15px 25px;
	background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
	color: #1a0b2e;
	border: none;
	border-radius: 50px;
	font-size: 16px;
	font-weight: bold;
	cursor: pointer;
	transition: all 0.3s;
	box-shadow: 0 10px 30px rgba(0, 255, 136, 0.4);
	z-index: 100;
	text-transform: uppercase;
	letter-spacing: 1px;
}

.launch-token-btn:hover {
	background: linear-gradient(135deg, #00cc6a 0%, #00aa55 100%);
	transform: translateY(-3px);
	box-shadow: 0 15px 40px rgba(0, 255, 136, 0.6);
}

.status-message {
	text-align: center;
	padding: 10px;
	margin: 10px 0;
	border-radius: 10px;
	font-weight: 500;
}

.status-success {
	background: rgba(0, 255, 136, 0.2);
	color: #00ff88;
	border: 1px solid #00ff88;
}

.status-error {
	background: rgba(255, 100, 100, 0.2);
	color: #ff6464;
	border: 1px solid #ff6464;
}

.status-info {
	background: rgba(124, 58, 237, 0.2);
	color: #7c3aed;
	border: 1px solid #7c3aed;
}

.status-warning {
	background: rgba(255, 193, 7, 0.2);
	color: #ffc107;
	border: 1px solid #ffc107;
}

/* Responsive design */
@media (max-width: 768px) {
	.modal-content {
		margin: 10% auto;
		padding: 20px;
		width: 95%;
	}
	
	.launch-token-btn {
		bottom: 20px;
		right: 20px;
		padding: 12px 20px;
		font-size: 14px;
	}
}
</style>
<script src="static/js/ge1doot.js"></script>
<script>
/* =======================================================
 *  ---- HTML5 CANVAS 3D drawing ----
 * script: Gerard Ferrandez - 7 February 2013
 * Released under the MIT license
 * http://www.dhteumeuleu.com/LICENSE.html
 * ======================================================= */
 
"use strict";

// Solana Configuration
const SOLANA_RPC_URL = 'https://magical-boldest-patina.solana-mainnet.quiknode.pro/a94255dcbb27e52b1d4cca35d10e899b82b6bdba/';
const PUMP_FUN_PROGRAM_ID = '6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P';
// Updated to use reliable PumpfunAPI.org service
const PUMPFUN_API_URL = 'https://api.pumpfunapi.org/pumpfun/create/token';

// Check if running on localhost
const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';

// Global Solana variables
let connection;
let wallet = null;
let walletAddress = null;
let privateKey = null; // Store private key for API calls

// Initialize Solana connection
function initializeSolana() {
    try {
        connection = new solanaWeb3.Connection(SOLANA_RPC_URL, 'confirmed');
        console.log('Solana connection initialized');
        
        // Enhanced Phantom detection for hosted environments
        const checkPhantom = () => {
            if (window.solana && window.solana.isPhantom) {
                console.log('Phantom wallet detected');
                return true;
            }
            return false;
        };
        
        // Wait a bit for Phantom to load in hosted environments
        if (!checkPhantom()) {
            setTimeout(() => {
                if (!checkPhantom()) {
                    console.warn('Phantom wallet not detected - may need to install or refresh');
                }
            }, 2000);
        }
    } catch (error) {
        console.error('Failed to initialize Solana:', error);
    }
}

// Connect to Phantom wallet
async function connectWallet() {
    try {
        // Enhanced Phantom detection for hosted environments
        if (!window.solana) {
            showStatus('Phantom wallet not found. Please install Phantom and refresh the page.', 'error');
            window.open('https://phantom.app/', '_blank');
            return false;
        }

        if (!window.solana.isPhantom) {
            showStatus('Please use Phantom wallet for the best experience.', 'warning');
        }

        showStatus('Connecting to Phantom wallet...', 'info');
        
        // Connect to wallet
        const response = await window.solana.connect({ onlyIfTrusted: false });
        wallet = window.solana;
        walletAddress = response.publicKey.toString();
        
        // Get private key for API calls (this is safe as it's the user's own wallet)
        // Note: In production, you might want to use a different approach for security
        try {
            // Request private key access for token creation
            const message = new TextEncoder().encode('Sign this message to authorize token creation');
            const signedMessage = await wallet.signMessage(message);
            
            // For the API, we'll need the wallet to sign transactions
            console.log('Wallet connected and ready for token creation');
        } catch (keyError) {
            console.log('Private key access not available, will use alternative method');
        }
        
        console.log('Wallet connected:', walletAddress);
        updateWalletUI();
        showStatus('Wallet connected successfully! Ready to create tokens.', 'success');
        
        return true;
    } catch (error) {
        console.error('Failed to connect wallet:', error);
        if (error.code === 4001) {
            showStatus('Wallet connection rejected by user', 'warning');
        } else if (error.code === -32002) {
            showStatus('Wallet connection request pending. Please check your Phantom wallet.', 'info');
        } else {
            showStatus('Failed to connect wallet: ' + error.message, 'error');
        }
        return false;
    }
}

// Disconnect wallet
async function disconnectWallet() {
    try {
        if (wallet) {
            await wallet.disconnect();
        }
        wallet = null;
        walletAddress = null;
        updateWalletUI();
        showStatus('Wallet disconnected', 'info');
    } catch (error) {
        console.error('Failed to disconnect wallet:', error);
    }
}

// Update wallet UI
function updateWalletUI() {
    const walletStatus = document.getElementById('walletStatus');
    const walletAddressEl = document.getElementById('walletAddress');
    const connectBtn = document.getElementById('connectWalletBtn');
    const launchBtn = document.getElementById('launchBtn');
    
    if (walletAddress) {
        walletStatus.textContent = 'Connected';
        walletStatus.style.color = '#00ff88';
        walletAddressEl.textContent = walletAddress.slice(0, 8) + '...' + walletAddress.slice(-8);
        connectBtn.textContent = 'Disconnect';
        connectBtn.onclick = disconnectWallet;
        launchBtn.disabled = false;
    } else {
        walletStatus.textContent = 'Not Connected';
        walletStatus.style.color = '#ff6464';
        walletAddressEl.textContent = '';
        connectBtn.textContent = 'Connect Phantom';
        connectBtn.onclick = connectWallet;
        launchBtn.disabled = true;
    }
}

// Helper function for associated token accounts (used by pump.fun functions)
async function getAssociatedTokenAddress(mint, owner) {
	const [address] = await solanaWeb3.PublicKey.findProgramAddress(
		[
			owner.toBytes(),
			new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA').toBytes(),
			mint.toBytes()
		],
		new solanaWeb3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL')
	);
	return address;
}

(function () {
	// ==== private variables =====
	var scr, ctx, pointer;
	var shapes = [];
	var sparks = [];
	var sparkId = 0;
	var fov = 650;
	var globalZ = 0;
	var xm = 0;
	var ym = 0;
	var auto = true;
	var currentShape;
	var start = true;
	
	// ==== Canvas screenshot functionality ====
	var captureCanvas = function() {
		// Get the canvas element directly from DOM
		var canvas = document.getElementById('screen');
		if (!canvas) {
			console.error('Canvas element not found');
			return null;
		}
		
		// Get the 2D context
		var context = canvas.getContext('2d');
		if (!context) {
			console.error('Canvas context not found');
			return null;
		}
		
		// Temporarily stop rotation for clean screenshot
		var wasAuto = auto;
		auto = false;
		
		// Clear and redraw one frame
		context.clearRect(0, 0, canvas.width, canvas.height);
		var i = 0, s;
		while ( s = shapes[i++]) {
			s.draw();
		}
		
		// Capture the canvas as image
		var dataURL = canvas.toDataURL('image/png');
		
		// Restore rotation state
		auto = wasAuto;
		
		console.log('Canvas captured successfully, data length:', dataURL.length);
		return dataURL;
	};
	
	// ==== spark object ====
	var Spark = function (x, y) {
		this.x = x;
		this.y = y;
		this.sx = Math.random() - 0.5;
		this.sy = 5 + Math.random() * 10;
	}
	// ==== draw sparks ====
	Spark.prototype.draw = function () {
		if (this.y < scr.height) {
			this.x += this.sx;
			this.y += this.sy;
			ctx.moveTo(this.x, this.y - 2);
			ctx.lineTo(this.x, this.y);
		}
	}
	// ==== shape object ====
	var Shape = function () {
		this.points = [];
		this.length = 0;
		this.filled = false;
		this.color = "";
		this.angle = 0;
		this.fov = fov;
		return this;
	}
	// ==== add point ====
	Shape.prototype.addPoint = function (x, y, z) {
		this.points.push(
			new Point(Math.round(x), Math.round(y), Math.round(z))
		);
		this.length++;
		if (Math.random() > -1) {
			sparks[sparkId++] = new Spark(x + scr.width * 0.5, y + scr.height * 0.5);
			sparks[sparkId++] = new Spark(x + scr.width * 0.5, y + scr.height * 0.5);
			sparks[sparkId++] = new Spark(x + scr.width * 0.5, y + scr.height * 0.5);
			sparks[sparkId++] = new Spark(x + scr.width * 0.5, y + scr.height * 0.5);
			sparks[sparkId++] = new Spark(x + scr.width * 0.5, y + scr.height * 0.5);
			sparks[sparkId++] = new Spark(x + scr.width * 0.5, y + scr.height * 0.5);
			if (sparkId == 100) sparkId = 0;
		}
	}
	// ==== rotate shape ====
	Shape.prototype.rotate = function () {
		// ---- increment angle ----
		this.angle += Math.PI / 180;
		var ax = Math.cos(this.angle);
		var ay = Math.sin(this.angle);
		// ---- points rotation ----
		for (var i = 0; i < this.length; i++) {
			this.points[i].rotate(ax, ay);
		}
	}
	// ==== draw shape ====
	Shape.prototype.draw = function () {
		if(this.points.length == 0)  return;

		// ---- 3D to 2D points projection ----
		for (var i = 0; i < this.length; i++) {
			this.points[i].project(this.fov);
		}
		// ---- draw smooth curve through N points ----
		var p0 = this.points[0];
		var lf = scr.width * 0.5;
		var tp = scr.height * 0.5;
		ctx.beginPath();
		ctx.moveTo(Math.random() * 3 - 1.5 + p0.xp + lf, Math.random() * 3 - 1.5 + p0.yp + tp);
		for (var i = 1, l = this.points.length; i < l; i++) {
			var p1 = this.points[i];
			var xc = Math.random() * 3 - 1.5 + (p0.xp + p1.xp) / 2;
			var yc = Math.random() * 3 - 1.5 + (p0.yp + p1.yp) / 2;
			ctx.quadraticCurveTo(p0.xp + lf, p0.yp + tp, xc + lf, yc + tp);
			p0 = p1;
		}
		// ---- paint ----
		ctx.strokeStyle = "#00ff88";
		ctx.lineWidth = 10;
		ctx.lineCap = "round";
		ctx.lineJoin = "round";
		if (this.filled) {
			ctx.closePath();
			ctx.fillStyle = this.color;
			ctx.fill();
		}
		ctx.stroke();
	}
	// ==== point object ====
	var Point = function (x, y, z) {
		this.x  = x;
		this.y  = y;
		this.z  = z;
		this.x0 = x;
		this.z0 = z;
		this.xp = 0;
		this.yp = 0;
		this.zp = 0;
	}
	// ==== 3D to 2D point projection ====
	Point.prototype.project = function (sfov) {
		this.zp = sfov / (sfov + this.z);
		this.xp = this.x * this.zp;
		this.yp = this.y * this.zp;
	}
	// ==== rotate point ====
	Point.prototype.rotate = function (ax, ay) {
		this.x = Math.round(this.x0 *  ax + this.z0 * ay);
		this.z = Math.round(this.x0 * -ay + this.z0 * ax);
	}
	// ==== painting pointer ====
	var movePointer = function () {
		if (pointer.isDown) {
			var dx = xm - pointer.X;
			var dy = ym - pointer.Y;
			var d = Math.sqrt(dx * dx + dy * dy);
			if (d > 10) {
				if (!currentShape) {
					if (start) {
						start = false;
						shapes.length = 0;
					}
					shapes.push(
						currentShape = new Shape()
					);
				}
				var z = fov / (fov + globalZ);
				currentShape.addPoint(
					(pointer.X - scr.width  * 0.5) / z, 
					(pointer.Y - scr.height * 0.5) / z, 
					globalZ
				);
				xm = pointer.X;
				ym = pointer.Y;
				// ---- closing shape ----
				currentShape.filled = false;
				currentShape.color = "";
				var first = currentShape.points[0];
				var last  = currentShape.points[currentShape.length - 1];
				var dx = last.x - first.x;
				var dy = last.y - first.y;
				var dz = last.z - first.z;
				var d = Math.sqrt(dx * dx + dy * dy + dz * dz);
				if (d < 15) {
					if (currentShape.length > 4) {
						currentShape.color = 'hsla(' + Math.round(Math.random() * 360) + ', 90%, 60%, 0.2)';
						currentShape.filled = true;
					}
				}
			}
		} else {
			// ---- up ----
			if (currentShape) {
				currentShape = false;
			}
			// ---- rotate ----
			if (auto) {
				var i = 0, s;
				while ( s = shapes[i++]) s.rotate();
			}
		}
	}
	// ==== save drawing ====
	var save = function (id) {
		// ---- clean up ----
		var array = shapes.slice(0);
		for (var i = 0; i < array.length; i++) {
			delete array[i].angle;
			var pts = array[i].points;
			for (var j = 0; j < pts.length; j++) {
				var p = pts[j];
				for (var k in p) {
					if (k.length != 1) delete p[k];
				}
			}
		}
		// ---- save json to local storage ----
		var a = JSON.stringify(array);
		window.localStorage.setItem(id, a);
		// ---- re-load ----
		load(id);
	}
	// ==== load drawing ====
	var load = function (id) {
		// ---- clear all ----
		shapes.length = 0;
		// ---- load ----
		var array = JSON.parse(window.localStorage.getItem(id));
		// ---- rebuild objects ----
		build(array);
	}
	// ==== inject data ====
	var build = function(array) {
		if (array) {
			for (var i = 0; i < array.length; i++) {
				shapes.push(
					currentShape = new Shape()
				);
				var p = array[i].points;
				for (var j = 0; j < p.length; j++) {
					currentShape.points.push(
						new Point(p[j].x, p[j].y, p[j].z)
					);
				}
				currentShape.length = array[i].length;
				currentShape.filled = array[i].filled;
				currentShape.color  = array[i].color;
			}
		}
	}
	// ==== init script ====
	var init = function (json) {
		// ---- screen ----
		scr = new ge1doot.Screen({
			container: "screen",
			resize: function () {
				fov = Math.round(scr.width * 0.5);
			}
		});
		scr.resize();
		ctx = scr.ctx;
		// ---- pointer events ----
		pointer = new ge1doot.Pointer({	});
		// ---- some key events ----
		document.body.onkeydown = function (e) {
			// ---- storage detection ----
			var storage = typeof window.localStorage == 'object';
			// ---- hold/release rotation [SPACE] ----
			if (e.keyCode == 32) {
				auto = !auto;
			}
			// ---- undo shapes [DEL] ----
			if (e.keyCode == 46) {
				if (shapes.length > 0) {
					shapes.length--;
				}
			}
			// ---- switch global Z [Z] ----
			if (e.keyCode == 90) {
				if (globalZ == 0) globalZ = fov * 0.35; else globalZ = 0;
			}
			// ---- save/load [S/L]----
			if (e.keyCode == 83 && storage) save("circumscrible");
			if (e.keyCode == 76 && storage) load("circumscrible");
			return false;
		}

		document.getElementById('clear').onclick = function(){
			currentShape = false;
			start = false;
			shapes.length = 0;
			shapes.push(
				currentShape = new Shape()
			);
		};
		document.getElementById('pause').onclick = function(){
			auto = !auto;
		};

		document.getElementById('back').onclick = function(){
			if (shapes.length > 0) {
					shapes.length--;
			}
		};

		// ---- intro drawing ----
		build(json);
		// ---- engine start ----
		run();
	}
	// ======== main loop ========
	var run = function () {
		ctx.clearRect(0, 0, scr.width, scr.height);
		movePointer();
		// ---- draw shapes ----
		var i = 0, s;
		while ( s = shapes[i++]) {
			s.draw();
		}
		// ---- sparks ----
		ctx.beginPath();
		var i = 0, s;
		while ( s = sparks[i++]) {
			s.draw();
		}
		ctx.lineWidth = 1;
		ctx.strokeStyle = "#00ff88";
		ctx.stroke();
		// ---- animation loop ----
		requestAnimFrame(run);
	}
	
	// ==== Expose captureCanvas function globally ====
	window.captureCanvas = captureCanvas;
	
	return {
		// ---- onload event ----
		load : function (json) {
			window.addEventListener('load', function () {
				init(json);
			}, false);
		}
	}
})().load([
	// P letter
	{"points":[{"x":-200,"y":-100,"z":0},{"x":-200,"y":-80,"z":0},{"x":-200,"y":-60,"z":0},{"x":-200,"y":-40,"z":0},{"x":-200,"y":-20,"z":0},{"x":-200,"y":0,"z":0},{"x":-200,"y":20,"z":0},{"x":-200,"y":40,"z":0},{"x":-200,"y":60,"z":0},{"x":-200,"y":80,"z":0},{"x":-200,"y":100,"z":0}],"length":11,"filled":false,"color":"","fov":640},
	{"points":[{"x":-200,"y":-100,"z":0},{"x":-180,"y":-100,"z":0},{"x":-160,"y":-100,"z":0},{"x":-140,"y":-100,"z":0},{"x":-120,"y":-100,"z":0}],"length":5,"filled":false,"color":"","fov":640},
	{"points":[{"x":-120,"y":-100,"z":0},{"x":-120,"y":-80,"z":0},{"x":-120,"y":-60,"z":0},{"x":-120,"y":-40,"z":0},{"x":-120,"y":-20,"z":0},{"x":-120,"y":0,"z":0}],"length":6,"filled":false,"color":"","fov":640},
	{"points":[{"x":-200,"y":0,"z":0},{"x":-180,"y":0,"z":0},{"x":-160,"y":0,"z":0},{"x":-140,"y":0,"z":0},{"x":-120,"y":0,"z":0}],"length":5,"filled":false,"color":"","fov":640},
	
	// U letter
	{"points":[{"x":-80,"y":-100,"z":0},{"x":-80,"y":-80,"z":0},{"x":-80,"y":-60,"z":0},{"x":-80,"y":-40,"z":0},{"x":-80,"y":-20,"z":0},{"x":-80,"y":0,"z":0},{"x":-80,"y":20,"z":0},{"x":-80,"y":40,"z":0},{"x":-80,"y":60,"z":0},{"x":-80,"y":80,"z":0},{"x":-80,"y":100,"z":0}],"length":11,"filled":false,"color":"","fov":640},
	{"points":[{"x":-80,"y":100,"z":0},{"x":-60,"y":100,"z":0},{"x":-40,"y":100,"z":0},{"x":-20,"y":100,"z":0},{"x":0,"y":100,"z":0}],"length":5,"filled":false,"color":"","fov":640},
	{"points":[{"x":0,"y":100,"z":0},{"x":0,"y":80,"z":0},{"x":0,"y":60,"z":0},{"x":0,"y":40,"z":0},{"x":0,"y":20,"z":0},{"x":0,"y":0,"z":0},{"x":0,"y":-20,"z":0},{"x":0,"y":-40,"z":0},{"x":0,"y":-60,"z":0},{"x":0,"y":-80,"z":0},{"x":0,"y":-100,"z":0}],"length":11,"filled":false,"color":"","fov":640},
	
	// M letter
	{"points":[{"x":40,"y":100,"z":0},{"x":40,"y":80,"z":0},{"x":40,"y":60,"z":0},{"x":40,"y":20,"z":0},{"x":40,"y":0,"z":0},{"x":40,"y":-20,"z":0},{"x":40,"y":-40,"z":0},{"x":40,"y":-60,"z":0},{"x":40,"y":-80,"z":0},{"x":40,"y":-100,"z":0}],"length":10,"filled":false,"color":"","fov":640},
	{"points":[{"x":40,"y":-100,"z":0},{"x":50,"y":-90,"z":0},{"x":60,"y":-80,"z":0},{"x":70,"y":-70,"z":0},{"x":80,"y":-60,"z":0},{"x":90,"y":-50,"z":0},{"x":100,"y":-40,"z":0}],"length":7,"filled":false,"color":"","fov":640},
	{"points":[{"x":100,"y":-40,"z":0},{"x":110,"y":-50,"z":0},{"x":120,"y":-60,"z":0},{"x":130,"y":-70,"z":0},{"x":140,"y":-80,"z":0},{"x":150,"y":-90,"z":0},{"x":160,"y":-100,"z":0}],"length":7,"filled":false,"color":"","fov":640},
	{"points":[{"x":160,"y":-100,"z":0},{"x":160,"y":-80,"z":0},{"x":160,"y":-60,"z":0},{"x":160,"y":-40,"z":0},{"x":160,"y":-20,"z":0},{"x":160,"y":0,"z":0},{"x":160,"y":20,"z":0},{"x":160,"y":40,"z":0},{"x":160,"y":60,"z":0},{"x":160,"y":80,"z":0},{"x":160,"y":100,"z":0}],"length":11,"filled":false,"color":"","fov":640},
	
	// P letter (second)
	{"points":[{"x":200,"y":-100,"z":0},{"x":200,"y":-80,"z":0},{"x":200,"y":-60,"z":0},{"x":200,"y":-40,"z":0},{"x":200,"y":-20,"z":0},{"x":200,"y":0,"z":0},{"x":200,"y":20,"z":0},{"x":200,"y":40,"z":0},{"x":200,"y":60,"z":0},{"x":200,"y":80,"z":0},{"x":200,"y":100,"z":0}],"length":11,"filled":false,"color":"","fov":640},
	{"points":[{"x":200,"y":-100,"z":0},{"x":220,"y":-100,"z":0},{"x":240,"y":-100,"z":0},{"x":260,"y":-100,"z":0},{"x":280,"y":-100,"z":0}],"length":5,"filled":false,"color":"","fov":640},
	{"points":[{"x":280,"y":-100,"z":0},{"x":280,"y":-80,"z":0},{"x":280,"y":-60,"z":0},{"x":280,"y":-40,"z":0},{"x":280,"y":-20,"z":0},{"x":280,"y":0,"z":0}],"length":6,"filled":false,"color":"","fov":640},
	{"points":[{"x":200,"y":0,"z":0},{"x":220,"y":0,"z":0},{"x":240,"y":0,"z":0},{"x":260,"y":0,"z":0},{"x":280,"y":0,"z":0}],"length":5,"filled":false,"color":"","fov":640},
	
	// Pump icon/symbol below text
	{"points":[{"x":-50,"y":150,"z":0},{"x":-30,"y":150,"z":0},{"x":-10,"y":150,"z":0},{"x":10,"y":150,"z":0},{"x":30,"y":150,"z":0},{"x":50,"y":150,"z":0}],"length":6,"filled":false,"color":"","fov":640},
	{"points":[{"x":0,"y":150,"z":0},{"x":0,"y":170,"z":0},{"x":0,"y":190,"z":0},{"x":0,"y":210,"z":0},{"x":0,"y":230,"z":0}],"length":5,"filled":false,"color":"","fov":640},
	{"points":[{"x":-30,"y":230,"z":0},{"x":-20,"y":230,"z":0},{"x":-10,"y":230,"z":0},{"x":0,"y":230,"z":0},{"x":10,"y":230,"z":0},{"x":20,"y":230,"z":0},{"x":30,"y":230,"z":0}],"length":7,"filled":false,"color":"","fov":640},
	{"points":[{"x":-30,"y":230,"z":0},{"x":-30,"y":240,"z":0},{"x":-30,"y":250,"z":0}],"length":3,"filled":false,"color":"","fov":640},
	{"points":[{"x":30,"y":230,"z":0},{"x":30,"y":240,"z":0},{"x":30,"y":250,"z":0}],"length":3,"filled":false,"color":"","fov":640},
	
	// Fun decorative elements (pump.fun style)
	{"points":[{"x":-150,"y":200,"z":50},{"x":-140,"y":190,"z":50},{"x":-130,"y":200,"z":50},{"x":-120,"y":190,"z":50},{"x":-110,"y":200,"z":50}],"length":5,"filled":false,"color":"","fov":640},
	{"points":[{"x":110,"y":200,"z":50},{"x":120,"y":190,"z":50},{"x":130,"y":200,"z":50},{"x":140,"y":190,"z":50},{"x":150,"y":200,"z":50}],"length":5,"filled":false,"color":"","fov":640},
	
	// Additional depth elements
	{"points":[{"x":-100,"y":-150,"z":-50},{"x":-80,"y":-150,"z":-50},{"x":-60,"y":-150,"z":-50},{"x":-40,"y":-150,"z":-50},{"x":-20,"y":-150,"z":-50},{"x":0,"y":-150,"z":-50},{"x":20,"y":-150,"z":-50},{"x":40,"y":-150,"z":-50},{"x":60,"y":-150,"z":-50},{"x":80,"y":-150,"z":-50},{"x":100,"y":-150,"z":-50}],"length":11,"filled":false,"color":"","fov":640},
	{"points":[{"x":-100,"y":300,"z":-50},{"x":-80,"y":300,"z":-50},{"x":-60,"y":300,"z":-50},{"x":-40,"y":300,"z":-50},{"x":-20,"y":300,"z":-50},{"x":0,"y":300,"z":-50},{"x":20,"y":300,"z":-50},{"x":40,"y":300,"z":-50},{"x":60,"y":300,"z":-50},{"x":80,"y":300,"z":-50},{"x":100,"y":300,"z":-50}],"length":11,"filled":false,"color":"","fov":640}
]);

// ==== Token Launch Functionality ====
function openTokenModal() {
	console.log('🚀 openTokenModal called - starting token launch process');
	try {
		// Capture the current canvas
		console.log('📸 Attempting to capture canvas...');
		var imageData = window.captureCanvas();
		console.log('📸 Canvas captured:', imageData ? 'SUCCESS' : 'FAILED');
		
		if (!imageData) {
			alert('❌ Failed to capture your artwork. Please try drawing something first!');
			return;
		}
		
		// Show the modal
		var modal = document.getElementById('tokenModal');
		if (modal) {
			modal.style.display = 'block';
			console.log('✅ Modal shown successfully');
		} else {
			console.error('❌ Modal element not found');
			alert('❌ Modal not found. Please refresh the page.');
			return;
		}
		
		// Set the preview image
		var previewImg = document.getElementById('previewImage');
		if (previewImg && imageData) {
			previewImg.src = imageData;
			console.log('✅ Preview image set successfully');
		} else {
			console.error('❌ Preview image element not found or no image data');
		}
		
		// Store the image data for later use
		window.currentArtwork = imageData;
		console.log('✅ Artwork stored globally');
		
		// Update wallet UI
		updateWalletUI();
		console.log('✅ Wallet UI updated');
		
		// Setup inputs with delay to ensure DOM is ready
		setTimeout(function() {
			setupInputs();
			console.log('✅ Inputs setup completed');
		}, 100);
		
	} catch (error) {
		console.error('❌ Critical error in openTokenModal:', error);
		alert('❌ Error opening token modal: ' + error.message);
	}
}

function setupInputs() {
	console.log('🔧 Setting up inputs...');
	
	// Generate random token name and ticker
	var randomNames = ['Space Art', 'Neon Dreams', 'Cyber Punk', 'Digital Gold', 'Quantum Wave', 'Retro Pump', 'Matrix Art', 'Future Token'];
	var randomTickers = ['SPCE', 'NEON', 'CYBR', 'DGLD', 'QNTM', 'RTRO', 'MTRX', 'FUTR'];
	
	var randomName = randomNames[Math.floor(Math.random() * randomNames.length)];
	var randomTicker = randomTickers[Math.floor(Math.random() * randomTickers.length)];
	
	var nameInput = document.getElementById('tokenName');
	var tickerInput = document.getElementById('tokenTicker');
	
	if (nameInput) {
		nameInput.value = randomName;
		console.log('✅ Name input auto-filled with:', randomName);
	} else {
		console.error('❌ Name input not found');
	}
	
	if (tickerInput) {
		tickerInput.value = randomTicker;
		console.log('✅ Ticker input auto-filled with:', randomTicker);
	} else {
		console.error('❌ Ticker input not found');
	}
}

// Simplified button click handler
function handleLaunchButtonClick() {
	console.log('🎯 Launch button clicked!');
	openTokenModal();
}

// Test function to verify button is working
function testButton() {
	console.log('🧪 Testing button functionality...');
	var button = document.getElementById('launchTokenBtn');
	if (button) {
		console.log('✅ Button found:', button);
		console.log('✅ Button visible:', button.offsetWidth > 0 && button.offsetHeight > 0);
		console.log('✅ Button onclick:', button.onclick);
		button.style.backgroundColor = '#ff0000'; // Flash red for visual confirmation
		setTimeout(() => {
			button.style.backgroundColor = '';
		}, 500);
	} else {
		console.error('❌ Button not found!');
	}
}

// Enhanced initialization
window.addEventListener('load', function() {
	console.log('🌟 Page loaded, initializing...');
	
	// Test button functionality
	setTimeout(() => {
		testButton();
	}, 1000);
	
	// Initialize Solana
	initializeSolana();
	
	// Add multiple event listeners for reliability
	var launchBtn = document.getElementById('launchTokenBtn');
	if (launchBtn) {
		// Remove any existing onclick to avoid conflicts
		launchBtn.onclick = null;
		
		// Add primary click handler
		launchBtn.addEventListener('click', function(e) {
			console.log('🎯 Launch button clicked via event listener');
			e.preventDefault();
			e.stopPropagation();
			handleLaunchButtonClick();
		});
		
		// Add backup onclick handler
		launchBtn.onclick = function(e) {
			console.log('🎯 Launch button clicked via onclick');
			e.preventDefault();
			handleLaunchButtonClick();
		};
		
		console.log('✅ Event listeners added to launch button');
	} else {
		console.error('❌ Launch button not found during initialization');
	}
	
	// Add keyboard shortcut for testing
	document.addEventListener('keydown', function(e) {
		if (e.key === 'L' || e.key === 'l') {
			console.log('🎹 Keyboard shortcut pressed - launching modal');
			openTokenModal();
		}
		if (e.key === 'T' || e.key === 't') {
			console.log('🧪 Testing button...');
			testButton();
		}
	});
	
	console.log('🎮 Keyboard shortcuts added: L = Launch Modal, T = Test Button');
});

// Add window click debugging
window.addEventListener('click', function(e) {
	console.log('🖱️ Window clicked:', e.target.tagName, e.target.id, e.target.className);
});

// Test function to verify everything is loaded
function testLaunchButton() {
	console.log('🧪 Testing launch button...');
	console.log('📋 captureCanvas function:', typeof window.captureCanvas);
	console.log('📋 Modal element:', document.getElementById('tokenModal') ? 'FOUND' : 'NOT FOUND');
	console.log('📋 Launch button:', document.querySelector('.launch-token-btn') ? 'FOUND' : 'NOT FOUND');
	console.log('📋 Launch button by ID:', document.getElementById('launchTokenBtn') ? 'FOUND' : 'NOT FOUND');
}

function closeTokenModal() {
	console.log('🔒 closeTokenModal called');
	var modal = document.getElementById('tokenModal');
	if (modal) {
		modal.style.display = 'none';
	}
	var statusMsg = document.getElementById('statusMessage');
	if (statusMsg) {
		statusMsg.innerHTML = '';
	}
}

function validateTokenForm() {
	var name = document.getElementById('tokenName').value.trim();
	var ticker = document.getElementById('tokenTicker').value.trim();
	
	if (name.length < 2) {
		showStatus('Token name must be at least 2 characters long', 'error');
		return false;
	}
	
	if (ticker.length < 2 || ticker.length > 10) {
		showStatus('Ticker must be between 2-10 characters', 'error');
		return false;
	}
	
	if (!/^[A-Z0-9]+$/.test(ticker)) {
		showStatus('Ticker must contain only uppercase letters and numbers', 'error');
		return false;
	}
	
	return true;
}

function showStatus(message, type) {
	var statusDiv = document.getElementById('statusMessage');
	if (statusDiv) {
		// Handle multi-line messages
		statusDiv.innerHTML = message.replace(/\n/g, '<br>');
		statusDiv.className = 'status-message status-' + type;
		
		// Auto-scroll to status message
		statusDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
	}
}

async function checkSufficientBalance() {
	try {
		if (!walletAddress) return false;
		
		const balance = await connection.getBalance(new solanaWeb3.PublicKey(walletAddress));
		const solBalance = balance / solanaWeb3.LAMPORTS_PER_SOL;
		
		console.log('💰 Wallet balance:', solBalance, 'SOL');
		
		if (solBalance < 0.01) {
			showStatus(`❌ Insufficient balance. You have ${solBalance.toFixed(4)} SOL, but need at least 0.01 SOL for token creation.`, 'error');
			return false;
		}
		
		return true;
	} catch (error) {
		console.error('Failed to check balance:', error);
		showStatus('Failed to check wallet balance. Please try again.', 'error');
		return false;
	}
}

async function launchToken() {
	console.log('🚀 launchToken called');
	
	if (!validateTokenForm()) {
		return;
	}
	
	if (!wallet || !walletAddress) {
		showStatus('Please connect your Phantom wallet first', 'error');
		return;
	}
	
	// Check balance
	const hasBalance = await checkSufficientBalance();
	if (!hasBalance) {
		return;
	}
	
	var name = document.getElementById('tokenName').value.trim();
	var ticker = document.getElementById('tokenTicker').value.trim();
	var launchBtn = document.getElementById('launchBtn');
	
	// Disable button and show loading
	if (launchBtn) {
		launchBtn.disabled = true;
		launchBtn.textContent = 'Launching...';
	}
	
	try {
		showStatus('Preparing your 3D artwork...', 'info');
		
		// Launch token directly with the artwork
		const success = await launchTokenOnPumpFun(name, ticker, window.currentArtwork);
		
		if (success) {
			setTimeout(() => {
				closeTokenModal();
				if (launchBtn) {
					launchBtn.disabled = false;
					launchBtn.textContent = '🚀 Create pump.fun Token';
				}
			}, 3000);
		} else {
			if (launchBtn) {
				launchBtn.disabled = false;
				launchBtn.textContent = '🚀 Create pump.fun Token';
			}
		}
		
	} catch (error) {
		console.error('Error in launchToken:', error);
		showStatus('Error launching token: ' + error.message, 'error');
		if (launchBtn) {
			launchBtn.disabled = false;
			launchBtn.textContent = '🚀 Create pump.fun Token';
		}
	}
}

// Close modal when clicking outside
window.onclick = function(event) {
	var modal = document.getElementById('tokenModal');
	if (event.target == modal) {
		closeTokenModal();
	}
}

// Enhanced token creation with direct Solana integration and pump.fun guidance
async function launchTokenOnPumpFun(name, symbol, imageUrl) {
	try {
		if (!wallet || !walletAddress) {
			throw new Error('Wallet not connected');
		}

		showStatus('🚀 Creating REAL pump.fun token with bonding curve...', 'info');
		
		// Create pump.fun token using their actual API
		return await createPumpFunTokenOnChain(name, symbol, imageUrl);
		
	} catch (error) {
		console.error('Pump.fun token creation error:', error);
		showStatus('Failed to create pump.fun token: ' + error.message, 'error');
		
		// Try fallback
		throw error;
	}
}

// Create pump.fun token on-chain using their actual program
async function createPumpFunTokenOnChain(name, symbol, metadataUri) {
	try {
		showStatus('⚡ Connecting to pump.fun API...', 'info');
		
		const userPublicKey = new solanaWeb3.PublicKey(walletAddress);
		
		// Try pump.fun's actual API endpoints
		let transactionData;
		
		// Method 1: Try pumpportal API
		try {
			const pumpApiUrl = 'https://pumpportal.fun/api/trade-local';
			
			const response = await fetch(pumpApiUrl, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({
					publicKey: walletAddress,
					action: 'create',
					tokenName: name,
					tokenTicker: symbol,
					description: `${name} - A unique 3D rotating artwork created with 3D Drawing Studio. Experience the future of meme tokens!`,
					imageUrl: metadataUri,
					initialBuy: 0.01,
					slippage: 10
				})
			});
			
			if (response.ok) {
				transactionData = await response.json();
			}
		} catch (error) {
			console.log('PumpPortal API not available, trying direct method');
		}
		
		// Method 2: Try pump.fun's main API
		if (!transactionData || !transactionData.transaction) {
			try {
				const directApiUrl = 'https://pump.fun/api/create-token';
				
				const formData = new FormData();
				
				// Convert metadata URI to blob if it's base64
				let imageBlob;
				if (metadataUri.startsWith('data:')) {
					const response = await fetch(metadataUri);
					imageBlob = await response.blob();
				} else {
					// Create a simple image blob
					const canvas = document.createElement('canvas');
					canvas.width = 400;
					canvas.height = 400;
					const ctx = canvas.getContext('2d');
					ctx.fillStyle = '#1a0b2e';
					ctx.fillRect(0, 0, 400, 400);
					ctx.fillStyle = '#00ff88';
					ctx.font = '48px Arial';
					ctx.textAlign = 'center';
					ctx.fillText(symbol, 200, 200);
					imageBlob = await new Promise(resolve => canvas.toBlob(resolve));
				}
				
				formData.append('name', name);
				formData.append('symbol', symbol);
				formData.append('description', `${name} - A unique 3D rotating artwork created with 3D Drawing Studio. Experience the future of meme tokens!`);
				formData.append('file', imageBlob, `${symbol}_artwork.png`);
				formData.append('twitter', '');
				formData.append('telegram', '');
				formData.append('website', '');
				formData.append('showName', 'true');
				
				const response = await fetch(directApiUrl, {
					method: 'POST',
					body: formData
				});
				
				if (response.ok) {
					const result = await response.json();
					if (result.signature) {
						// Token was created successfully via API
						showStatus(`🎉 PUMP.FUN TOKEN CREATED VIA API!<br><br>` +
							`🚀 <strong>${name} (${symbol})</strong><br>` +
							`✅ Transaction: <a href="https://solscan.io/tx/${result.signature}" target="_blank" style="color: #00ff88; text-decoration: underline;">${result.signature.slice(0, 8)}...${result.signature.slice(-8)}</a><br><br>` +
							`🔥 <strong>Your token is now LIVE on pump.fun!</strong><br>` +
							`💰 <a href="https://pump.fun" target="_blank" style="color: #00ff88; text-decoration: underline; font-weight: bold;">Find and Trade Your Token →</a><br>` +
							`🎨 Your 3D artwork is the official token image!`, 'success');
						return true;
					}
				}
			} catch (error) {
				console.log('Direct pump.fun API not available');
			}
		}
		
		// Method 3: If APIs don't work, create a compatible transaction manually
		if (!transactionData || !transactionData.transaction) {
			throw new Error('pump.fun APIs are not accessible from this domain. Using fallback method.');
		}
		
		showStatus('✍️ Please approve the pump.fun token creation in Phantom...', 'info');
		
		// Deserialize the transaction
		const tx = solanaWeb3.Transaction.from(Buffer.from(transactionData.transaction, 'base64'));
		
		// Sign the transaction with user's wallet
		const signedTx = await wallet.signTransaction(tx);
		
		showStatus('🚀 Launching your pump.fun token...', 'info');
		
		// Send the signed transaction
		const signature = await connection.sendRawTransaction(signedTx.serialize(), {
			skipPreflight: false,
			preflightCommitment: 'confirmed'
		});
		
		showStatus('⏳ Confirming pump.fun token creation...', 'info');
		
		// Confirm the transaction
		const confirmation = await connection.confirmTransaction(signature, 'confirmed');
		
		if (confirmation.value.err) {
			throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));
		}
		
		// Parse transaction to get mint address
		const mintAddress = await getMintAddressFromTransaction(signature);
		
		showStatus(`🎉 PUMP.FUN TOKEN CREATED SUCCESSFULLY!<br><br>` +
			`🚀 <strong>${name} (${symbol})</strong><br>` +
			`✅ Mint: <a href="https://pump.fun/${mintAddress}" target="_blank" style="color: #00ff88; text-decoration: underline;">${mintAddress}</a><br>` +
			`✅ Transaction: <a href="https://solscan.io/tx/${signature}" target="_blank" style="color: #00ff88; text-decoration: underline;">${signature.slice(0, 8)}...${signature.slice(-8)}</a><br><br>` +
			`🔥 <strong>Your token is now LIVE on pump.fun!</strong><br>` +
			`💰 <a href="https://pump.fun/${mintAddress}" target="_blank" style="color: #00ff88; text-decoration: underline; font-weight: bold;">Trade Now →</a><br>` +
			`📊 Bonding curve started with your initial buy!<br>` +
			`🎨 Your 3D artwork is the official token image!`, 'success');
		
		return true;
		
	} catch (error) {
		console.error('Pump.fun on-chain creation failed:', error);
		showStatus('❌ Failed to create pump.fun token directly: ' + error.message, 'error');
		
		// Try fallback
		throw error;
	}
}

// Helper function to extract mint address from transaction
async function getMintAddressFromTransaction(signature) {
	try {
		// Wait a bit for transaction to be processed
		await new Promise(resolve => setTimeout(resolve, 2000));
		
		// Get transaction details
		const txDetails = await connection.getTransaction(signature, {
			commitment: 'confirmed',
			maxSupportedTransactionVersion: 0
		});
		
		if (txDetails && txDetails.meta && txDetails.meta.postTokenBalances) {
			// Find the mint address from token balances
			for (const balance of txDetails.meta.postTokenBalances) {
				if (balance.mint) {
					return balance.mint;
				}
			}
		}
		
		// Fallback: try to parse from logs
		if (txDetails && txDetails.meta && txDetails.meta.logMessages) {
			for (const log of txDetails.meta.logMessages) {
				if (log.includes('mint')) {
					// Extract mint address from log message if possible
					const mintMatch = log.match(/[1-9A-HJ-NP-Za-km-z]{32,44}/);
					if (mintMatch) {
						return mintMatch[0];
					}
				}
			}
		}
		
		// If we can't find it, return a placeholder
		return 'unknown';
		
	} catch (error) {
		console.error('Failed to get mint address:', error);
		return 'unknown';
	}
}

// Fallback: Open pump.fun create page with pre-filled data
async function redirectToPumpFunCreate(name, symbol, imageUrl) {
	try {
		showStatus('🎯 Opening pump.fun token creator...', 'info');
		
		// Download the artwork for user
		const link = document.createElement('a');
		link.href = imageUrl;
		link.download = `${symbol}_3D_artwork.png`;
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
		
		// Create pump.fun URL with pre-filled data
		const description = encodeURIComponent(`${name} - A unique 3D rotating artwork created with 3D Drawing Studio. Experience the future of meme tokens!`);
		const pumpFunUrl = `https://pump.fun/create?name=${encodeURIComponent(name)}&symbol=${encodeURIComponent(symbol)}&description=${description}`;
		
		// Open pump.fun in new tab
		window.open(pumpFunUrl, '_blank');
		
		showStatus(`🎨 <strong>ARTWORK DOWNLOADED!</strong><br><br>` +
			`🚀 pump.fun is opening in a new tab with:<br>` +
			`• Name: <strong>${name}</strong><br>` +
			`• Symbol: <strong>${symbol}</strong><br>` +
			`• Description: Pre-filled<br><br>` +
			`📥 <strong>Next steps:</strong><br>` +
			`1. Upload the downloaded ${symbol}_3D_artwork.png<br>` +
			`2. Click "Create Token" on pump.fun<br>` +
			`3. Your token will be LIVE with bonding curve!<br><br>` +
			`🔥 <strong>Your 3D art will be the official token image!</strong>`, 'success');
		
		return true;
		
	} catch (error) {
		console.error('Fallback creation failed:', error);
		showStatus('Failed to open pump.fun creator: ' + error.message, 'error');
		return false;
	}
}
</script>
</head>
<body>
<canvas id="screen">Your browser doesn't support HTML5 canvas technology. Please use Google Chrome.</canvas>

<!-- Launch Token Button -->
<button class="launch-token-btn" onclick="handleLaunchButtonClick()" id="launchTokenBtn">🚀 Create pump.fun Token</button>

<!-- Token Launch Modal -->
<div id="tokenModal" class="modal">
	<div class="modal-content">
		<span class="close" onclick="closeTokenModal()">&times;</span>
		<h2>🚀 Launch Your Token on Pump.fun</h2>
		
		<div class="preview-container">
			<img id="previewImage" class="preview-image" alt="Your 3D Artwork" />
		</div>
		
		<!-- Wallet Connection Section -->
		<div class="wallet-section">
			<div class="wallet-status">
				<div>
					<strong>Phantom Wallet:</strong> <span id="walletStatus">Not Connected</span>
				</div>
				<button id="connectWalletBtn" class="connect-wallet-btn" onclick="connectWallet()">
					Connect Phantom
				</button>
			</div>
			<div id="walletAddress" class="wallet-address"></div>
		</div>
		
		<div style="margin: 20px 0;">
			<label style="display: block; color: #fff; margin-bottom: 8px; font-weight: 500;">Token Name:</label>
			<input 
				type="text" 
				id="tokenName" 
				placeholder="Enter token name"
				style="width: 100%; padding: 12px; border: 2px solid #444; border-radius: 10px; background: #2a1f3d; color: #fff; font-size: 16px; box-sizing: border-box; outline: none;"
			/>
		</div>
		
		<div style="margin: 20px 0;">
			<label style="display: block; color: #fff; margin-bottom: 8px; font-weight: 500;">Ticker Symbol:</label>
			<input 
				type="text" 
				id="tokenTicker" 
				placeholder="Enter ticker"
				style="width: 100%; padding: 12px; border: 2px solid #444; border-radius: 10px; background: #2a1f3d; color: #fff; font-size: 16px; box-sizing: border-box; outline: none;"
			/>
		</div>
		
		<div id="statusMessage"></div>
		
		<button id="launchBtn" class="launch-btn" onclick="launchToken()" disabled>
			🚀 Create pump.fun Token
		</button>
		
		<div style="margin-top: 15px; text-align: center; color: #aaa; font-size: 12px;">
			Your 3D artwork will be used as the token image.<br>
			Description will be left empty as requested.<br>
			<strong>Phantom wallet will sign the transaction securely.</strong>
		</div>
	</div>
</div>

<!-- dhteumeuleu nav menu -->
<div id="nav">
	<input type="checkbox" name="nav-switch" id="nav-switch">
	<label class="label" for="nav-switch">
		<div class="container">
			<div class="nav-on">
				<ul class="menu">
					<li class="home"><a target="_top" href="/">Home</a></li>
					<li class="list"><a id='clear' href="javascript:void();">Clear</a></li>
					<li class="arrow back"><a id='pause' href="javascript:void();">Pause</a></li>
					<li class="arrow"><a id='back' href="javascript:void();">Undo</a></li>				</ul>
			</div>
			<div class="nav-off">
				<div id="icon"><div></div><div></div></div>
				<h1 class="title">What would your name look like in 3D?<br>Draw it and find out!</h1>
			</div>
		</div>
	</label>
</div> 
<!-- end of dhteumeuleu nav menu -->

</body>
</html>