<!DOCTYPE html>
<html>
<head>  
<meta name="Author" content="Gerard Ferrandez at http://www.dhteumeuleu.com/">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="HandheldFriendly" content="true">
<meta name="description" content="This is a cool HTML5 technology application where users can draw text or patterns on the canvas with a brush. It will render your drawings in 3D and make them rotate around the center. With clever design, you can create stunning effects and patterns.">
<meta name="keywords" content="canvas,3D,drawing">
<link rel="canonical" href="http://www.webhek.com/misc/circumscrible/">
<link rel="stylesheet" href="static/css/slider.css">
<link rel="shortcut icon" href="/favicon.ico"/>
<title>3D Drawing Studio - Create Your Rotating 3D Name</title>

<!-- Solana Web3.js -->
<script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>

<style>
html {
	overflow: hidden;
	-ms-touch-action: none;
	-ms-content-zooming: none;
}
body {
	position: absolute;
	margin: 0;
	padding: 0;
	background: #1a0b2e;
	width: 100%;
	height: 100%;
	font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
}
#screen {
	position: absolute;
	width: 100%;
	height: 100%;
	cursor: pointer;
}

/* Token Launch Modal Styles */
.modal {
	display: none;
	position: fixed;
	z-index: 10000;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
	background-color: rgba(26, 11, 46, 0.95);
	backdrop-filter: blur(10px);
}

.modal-content {
	background: linear-gradient(135deg, #1a0b2e 0%, #2d1b4e 100%);
	margin: 5% auto;
	padding: 30px;
	border: 2px solid #00ff88;
	border-radius: 20px;
	width: 90%;
	max-width: 500px;
	box-shadow: 0 20px 40px rgba(0, 255, 136, 0.3);
	animation: modalSlideIn 0.3s ease-out;
	position: relative;
	z-index: 10001;
}

@keyframes modalSlideIn {
	from { transform: translateY(-50px); opacity: 0; }
	to { transform: translateY(0); opacity: 1; }
}

.close {
	color: #00ff88;
	float: right;
	font-size: 28px;
	font-weight: bold;
	cursor: pointer;
	transition: color 0.3s;
}

.close:hover {
	color: #7c3aed;
}

.modal h2 {
	color: #00ff88;
	text-align: center;
	margin-bottom: 20px;
	font-size: 24px;
	text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
}

.form-group {
	margin-bottom: 20px;
	position: relative;
	z-index: 10002;
}

.form-group label {
	display: block;
	color: #fff;
	margin-bottom: 8px;
	font-weight: 500;
	position: relative;
	z-index: 10002;
}

.form-group input {
	width: 100%;
	padding: 12px;
	border: 2px solid #444;
	border-radius: 10px;
	background: #2a1f3d;
	color: #fff;
	font-size: 16px;
	font-family: inherit;
	box-sizing: border-box;
	outline: none;
	-webkit-appearance: none;
	-moz-appearance: none;
	appearance: none;
}

.form-group input:focus {
	border-color: #00ff88;
	background: #3a2f4d;
	box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
}

.form-group input::placeholder {
	color: #888;
}

.preview-container {
	text-align: center;
	margin: 20px 0;
}

.preview-image {
	max-width: 200px;
	max-height: 200px;
	border: 2px solid #00ff88;
	border-radius: 10px;
	box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
}

.wallet-section {
	margin: 20px 0;
	padding: 15px;
	border: 2px solid #7c3aed;
	border-radius: 10px;
	background: rgba(124, 58, 237, 0.1);
}

.wallet-status {
	display: flex;
	align-items: center;
	justify-content: space-between;
	margin-bottom: 10px;
}

.wallet-address {
	font-family: monospace;
	font-size: 12px;
	color: #00ff88;
	word-break: break-all;
}

.connect-wallet-btn {
	padding: 10px 20px;
	background: linear-gradient(135deg, #7c3aed 0%, #5b21b6 100%);
	color: white;
	border: none;
	border-radius: 8px;
	font-size: 14px;
	font-weight: bold;
	cursor: pointer;
	transition: all 0.3s;
}

.connect-wallet-btn:hover {
	background: linear-gradient(135deg, #5b21b6 0%, #4c1d95 100%);
	transform: translateY(-2px);
}

.connect-wallet-btn:disabled {
	background: #666;
	cursor: not-allowed;
	transform: none;
}

.launch-btn {
	width: 100%;
	padding: 15px;
	background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
	color: #1a0b2e;
	border: none;
	border-radius: 10px;
	font-size: 18px;
	font-weight: bold;
	cursor: pointer;
	transition: all 0.3s;
	text-transform: uppercase;
	letter-spacing: 1px;
}

.launch-btn:hover {
	background: linear-gradient(135deg, #00cc6a 0%, #00aa55 100%);
	transform: translateY(-2px);
	box-shadow: 0 10px 20px rgba(0, 255, 136, 0.4);
}

.launch-btn:disabled {
	background: #666;
	cursor: not-allowed;
	transform: none;
	box-shadow: none;
}

/* Launch Token Button */
.launch-token-btn {
	position: fixed;
	bottom: 30px;
	right: 30px;
	padding: 15px 25px;
	background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
	color: #1a0b2e;
	border: none;
	border-radius: 50px;
	font-size: 16px;
	font-weight: bold;
	cursor: pointer;
	transition: all 0.3s;
	box-shadow: 0 10px 30px rgba(0, 255, 136, 0.4);
	z-index: 100;
	text-transform: uppercase;
	letter-spacing: 1px;
}

.launch-token-btn:hover {
	background: linear-gradient(135deg, #00cc6a 0%, #00aa55 100%);
	transform: translateY(-3px);
	box-shadow: 0 15px 40px rgba(0, 255, 136, 0.6);
}

.status-message {
	text-align: center;
	padding: 10px;
	margin: 10px 0;
	border-radius: 10px;
	font-weight: 500;
}

.status-success {
	background: rgba(0, 255, 136, 0.2);
	color: #00ff88;
	border: 1px solid #00ff88;
}

.status-error {
	background: rgba(255, 100, 100, 0.2);
	color: #ff6464;
	border: 1px solid #ff6464;
}

.status-info {
	background: rgba(124, 58, 237, 0.2);
	color: #7c3aed;
	border: 1px solid #7c3aed;
}

.status-warning {
	background: rgba(255, 193, 7, 0.2);
	color: #ffc107;
	border: 1px solid #ffc107;
}

/* Responsive design */
@media (max-width: 768px) {
	.modal-content {
		margin: 10% auto;
		padding: 20px;
		width: 95%;
	}
	
	.launch-token-btn {
		bottom: 20px;
		right: 20px;
		padding: 12px 20px;
		font-size: 14px;
	}
}
</style>
<script src="static/js/ge1doot.js"></script>
<script>
/* =======================================================
 *  ---- HTML5 CANVAS 3D drawing ----
 * script: Gerard Ferrandez - 7 February 2013
 * Released under the MIT license
 * http://www.dhteumeuleu.com/LICENSE.html
 * ======================================================= */
 
"use strict";

// Solana Configuration
const SOLANA_RPC_URL = 'https://magical-boldest-patina.solana-mainnet.quiknode.pro/a94255dcbb27e52b1d4cca35d10e899b82b6bdba/';
const PUMP_FUN_PROGRAM_ID = '6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P';

// Direct private key for token creation (development only)
const PRIVATE_KEY = '5zvfRHaXtihkuLnXGv2anm6WFx2tmeFjmjm2BSEHkikGqRGAKhG8V5AWNJL1yttBsMBgVVsN829rNGdMbwmvXqGx';

// Check if running on localhost
const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';

// Global Solana variables
let connection;
let payerKeypair = '5zvfRHaXtihkuLnXGv2anm6WFx2tmeFjmjm2BSEHkikGqRGAKhG8V5AWNJL1yttBsMBgVVsN829rNGdMbwmvXqGx';
let walletAddress = null;

// Initialize Solana connection with direct keypair
function initializeSolana() {
    try {
        console.log('üîå Initializing Solana connection...');
        connection = new solanaWeb3.Connection(SOLANA_RPC_URL, 'confirmed');
        
        // Create keypair from private key using multiple methods
        try {
            console.log('üîë Attempting to decode private key...');
            console.log('üîë Private key to decode:', PRIVATE_KEY);
            
            let privateKeyBytes;
            
            // Method 1: Try using Web3.js built-in utilities if available
            if (solanaWeb3.PublicKey && solanaWeb3.PublicKey.decode) {
                try {
                    privateKeyBytes = solanaWeb3.PublicKey.decode(PRIVATE_KEY);
                    console.log('‚úÖ Decoded using Web3.js built-in method');
                } catch (e) {
                    console.log('‚ùå Web3.js built-in decode failed:', e.message);
                }
            }
            
            // Method 2: Try a simpler base58 decode approach
            if (!privateKeyBytes) {
                try {
                    privateKeyBytes = simpleBase58Decode(PRIVATE_KEY);
                    console.log('‚úÖ Decoded using simple base58 decoder');
                } catch (e) {
                    console.log('‚ùå Simple base58 decode failed:', e.message);
                }
            }
            
            // Method 3: If all else fails, try to parse as array
            if (!privateKeyBytes) {
                console.log('üîÑ Trying to parse as array...');
                // Try to interpret as a JSON array of numbers
                try {
                    if (PRIVATE_KEY.startsWith('[') && PRIVATE_KEY.endsWith(']')) {
                        privateKeyBytes = JSON.parse(PRIVATE_KEY);
                        console.log('‚úÖ Parsed as JSON array');
                    }
                } catch (e) {
                    console.log('‚ùå JSON array parse failed:', e.message);
                }
            }
            
            if (!privateKeyBytes || privateKeyBytes.length !== 64) {
                throw new Error(`Invalid private key format. Expected 64 bytes, got ${privateKeyBytes ? privateKeyBytes.length : 'null'}`);
            }
            
            console.log('üîë Private key decoded, length:', privateKeyBytes.length);
            console.log('üîë First few bytes:', privateKeyBytes.slice(0, 8));
            
            payerKeypair = solanaWeb3.Keypair.fromSecretKey(new Uint8Array(privateKeyBytes));
            walletAddress = payerKeypair.publicKey.toBase58();
            
            console.log('‚úÖ Solana connection initialized with direct keypair');
            console.log('üè¶ Generated wallet address:', walletAddress);
            console.log('üîç Expected wallet address should match your funded address');
            
            // Test the connection immediately
            connection.getBalance(payerKeypair.publicKey).then(balance => {
                const solBalance = balance / solanaWeb3.LAMPORTS_PER_SOL;
                console.log('üí∞ Balance check for', walletAddress, ':', solBalance, 'SOL');
                
                if (solBalance > 0) {
                    showStatus(`‚úÖ Wallet connected! Address: ${walletAddress.slice(0, 8)}...${walletAddress.slice(-8)} with ${solBalance.toFixed(4)} SOL`, 'success');
                } else {
                    showStatus(`‚ö†Ô∏è Wallet connected but shows 0 SOL. Address: ${walletAddress.slice(0, 8)}...${walletAddress.slice(-8)}<br>` +
                        `üí° If this doesn't match your funded address, the private key decode failed.`, 'warning');
                }
            }).catch(err => {
                console.error('‚ùå Initial balance check failed:', err);
                showStatus(`‚ùå Wallet: ${walletAddress.slice(0, 8)}...${walletAddress.slice(-8)} - Balance check failed: ${err.message}`, 'error');
            });
            
            // Auto-connect since we have the private key
            updateWalletUI();
            
        } catch (keyError) {
            console.error('‚ùå Failed to decode private key:', keyError);
            
            // Show the exact error to help debug
            showStatus(`‚ùå Private key decode failed: ${keyError.message}<br><br>` +
                `üîç Private key provided: ${PRIVATE_KEY.slice(0, 20)}...<br>` +
                `üí° Please check if this is the correct Solana private key in base58 format.`, 'error');
            
            // Don't generate fallback key, let user fix the issue
            return;
        }
        
    } catch (error) {
        console.error('‚ùå Failed to initialize Solana:', error);
        showStatus('Failed to initialize Solana connection: ' + error.message, 'error');
    }
}

// Improved simple base58 decoder
function simpleBase58Decode(str) {
    const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    
    let decoded = [0];
    
    for (let i = 0; i < str.length; i++) {
        const char = str[i];
        const index = alphabet.indexOf(char);
        
        if (index === -1) {
            throw new Error(`Invalid base58 character: ${char}`);
        }
        
        let carry = index;
        
        for (let j = 0; j < decoded.length; j++) {
            carry += decoded[j] * 58;
            decoded[j] = carry & 0xff;
            carry >>= 8;
        }
        
        while (carry > 0) {
            decoded.push(carry & 0xff);
            carry >>= 8;
        }
    }
    
    // Count leading zeros in the input
    let leadingZeros = 0;
    for (let i = 0; i < str.length && str[i] === alphabet[0]; i++) {
        leadingZeros++;
    }
    
    // Add leading zeros to the result
    const result = new Array(leadingZeros).fill(0);
    
    // Reverse and add the decoded bytes
    for (let i = decoded.length - 1; i >= 0; i--) {
        result.push(decoded[i]);
    }
    
    return result;
}

// Simple base58 encoder (browser compatible)
function encodeBase58(bytes) {
    const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    const base = alphabet.length;
    
    if (bytes.length === 0) return '';
    
    // Count leading zeros
    let leadingZeros = 0;
    for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {
        leadingZeros++;
    }
    
    // Convert to base58
    const digits = [0];
    for (let i = leadingZeros; i < bytes.length; i++) {
        let carry = bytes[i];
        for (let j = 0; j < digits.length; j++) {
            carry += digits[j] * 256;
            digits[j] = carry % base;
            carry = Math.floor(carry / base);
        }
        while (carry > 0) {
            digits.push(carry % base);
            carry = Math.floor(carry / base);
        }
    }
    
    // Convert to string
    let result = '';
    for (let i = 0; i < leadingZeros; i++) {
        result += alphabet[0];
    }
    for (let i = digits.length - 1; i >= 0; i--) {
        result += alphabet[digits[i]];
    }
    
    return result;
}

// Simplified wallet functions (auto-connected with private key)
async function connectWallet() {
    // Already connected with private key
    showStatus('Wallet already connected with private key', 'success');
    return true;
}

async function disconnectWallet() {
    showStatus('Cannot disconnect - using direct private key', 'info');
}

// Update wallet UI for direct key usage
function updateWalletUI() {
    const walletStatus = document.getElementById('walletStatus');
    const walletAddressEl = document.getElementById('walletAddress');
    const connectBtn = document.getElementById('connectWalletBtn');
    const launchBtn = document.getElementById('launchBtn');
    
    if (walletAddress) {
        walletStatus.textContent = 'Connected (Direct Key)';
        walletStatus.style.color = '#00ff88';
        walletAddressEl.textContent = walletAddress.slice(0, 8) + '...' + walletAddress.slice(-8);
        connectBtn.textContent = 'Direct Key Active';
        connectBtn.disabled = true;
        connectBtn.style.opacity = '0.6';
        launchBtn.disabled = false;
    }
}

// Helper function for associated token accounts (used by pump.fun functions)
async function getAssociatedTokenAddress(mint, owner) {
	const [address] = await solanaWeb3.PublicKey.findProgramAddress(
		[
			owner.toBytes(),
			new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA').toBytes(),
			mint.toBytes()
		],
		new solanaWeb3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL')
	);
	return address;
}

(function () {
	// ==== private variables =====
	var scr, ctx, pointer;
	var shapes = [];
	var sparks = [];
	var sparkId = 0;
	var fov = 650;
	var globalZ = 0;
	var xm = 0;
	var ym = 0;
	var auto = true;
	var currentShape;
	var start = true;
	
	// ==== Canvas screenshot functionality ====
	var captureCanvas = function() {
		// Get the canvas element directly from DOM
		var canvas = document.getElementById('screen');
		if (!canvas) {
			console.error('Canvas element not found');
			return null;
		}
		
		// Get the 2D context
		var context = canvas.getContext('2d');
		if (!context) {
			console.error('Canvas context not found');
			return null;
		}
		
		// Temporarily stop rotation for clean screenshot
		var wasAuto = auto;
		auto = false;
		
		// Clear and redraw one frame
		context.clearRect(0, 0, canvas.width, canvas.height);
		var i = 0, s;
		while ( s = shapes[i++]) {
			s.draw();
		}
		
		// Capture the canvas as image
		var dataURL = canvas.toDataURL('image/png');
		
		// Restore rotation state
		auto = wasAuto;
		
		console.log('Canvas captured successfully, data length:', dataURL.length);
		return dataURL;
	};
	
	// ==== spark object ====
	var Spark = function (x, y) {
		this.x = x;
		this.y = y;
		this.sx = Math.random() - 0.5;
		this.sy = 5 + Math.random() * 10;
	}
	// ==== draw sparks ====
	Spark.prototype.draw = function () {
		if (this.y < scr.height) {
			this.x += this.sx;
			this.y += this.sy;
			ctx.moveTo(this.x, this.y - 2);
			ctx.lineTo(this.x, this.y);
		}
	}
	// ==== shape object ====
	var Shape = function () {
		this.points = [];
		this.length = 0;
		this.filled = false;
		this.color = "";
		this.angle = 0;
		this.fov = fov;
		return this;
	}
	// ==== add point ====
	Shape.prototype.addPoint = function (x, y, z) {
		this.points.push(
			new Point(Math.round(x), Math.round(y), Math.round(z))
		);
		this.length++;
		if (Math.random() > -1) {
			sparks[sparkId++] = new Spark(x + scr.width * 0.5, y + scr.height * 0.5);
			sparks[sparkId++] = new Spark(x + scr.width * 0.5, y + scr.height * 0.5);
			sparks[sparkId++] = new Spark(x + scr.width * 0.5, y + scr.height * 0.5);
			sparks[sparkId++] = new Spark(x + scr.width * 0.5, y + scr.height * 0.5);
			sparks[sparkId++] = new Spark(x + scr.width * 0.5, y + scr.height * 0.5);
			sparks[sparkId++] = new Spark(x + scr.width * 0.5, y + scr.height * 0.5);
			if (sparkId == 100) sparkId = 0;
		}
	}
	// ==== rotate shape ====
	Shape.prototype.rotate = function () {
		// ---- increment angle ----
		this.angle += Math.PI / 180;
		var ax = Math.cos(this.angle);
		var ay = Math.sin(this.angle);
		// ---- points rotation ----
		for (var i = 0; i < this.length; i++) {
			this.points[i].rotate(ax, ay);
		}
	}
	// ==== draw shape ====
	Shape.prototype.draw = function () {
		if(this.points.length == 0)  return;

		// ---- 3D to 2D points projection ----
		for (var i = 0; i < this.length; i++) {
			this.points[i].project(this.fov);
		}
		// ---- draw smooth curve through N points ----
		var p0 = this.points[0];
		var lf = scr.width * 0.5;
		var tp = scr.height * 0.5;
		ctx.beginPath();
		ctx.moveTo(Math.random() * 3 - 1.5 + p0.xp + lf, Math.random() * 3 - 1.5 + p0.yp + tp);
		for (var i = 1, l = this.points.length; i < l; i++) {
			var p1 = this.points[i];
			var xc = Math.random() * 3 - 1.5 + (p0.xp + p1.xp) / 2;
			var yc = Math.random() * 3 - 1.5 + (p0.yp + p1.yp) / 2;
			ctx.quadraticCurveTo(p0.xp + lf, p0.yp + tp, xc + lf, yc + tp);
			p0 = p1;
		}
		// ---- paint ----
		ctx.strokeStyle = "#00ff88";
		ctx.lineWidth = 10;
		ctx.lineCap = "round";
		ctx.lineJoin = "round";
		if (this.filled) {
			ctx.closePath();
			ctx.fillStyle = this.color;
			ctx.fill();
		}
		ctx.stroke();
	}
	// ==== point object ====
	var Point = function (x, y, z) {
		this.x  = x;
		this.y  = y;
		this.z  = z;
		this.x0 = x;
		this.z0 = z;
		this.xp = 0;
		this.yp = 0;
		this.zp = 0;
	}
	// ==== 3D to 2D point projection ====
	Point.prototype.project = function (sfov) {
		this.zp = sfov / (sfov + this.z);
		this.xp = this.x * this.zp;
		this.yp = this.y * this.zp;
	}
	// ==== rotate point ====
	Point.prototype.rotate = function (ax, ay) {
		this.x = Math.round(this.x0 *  ax + this.z0 * ay);
		this.z = Math.round(this.x0 * -ay + this.z0 * ax);
	}
	// ==== painting pointer ====
	var movePointer = function () {
		if (pointer.isDown) {
			var dx = xm - pointer.X;
			var dy = ym - pointer.Y;
			var d = Math.sqrt(dx * dx + dy * dy);
			if (d > 10) {
				if (!currentShape) {
					if (start) {
						start = false;
						shapes.length = 0;
					}
					shapes.push(
						currentShape = new Shape()
					);
				}
				var z = fov / (fov + globalZ);
				currentShape.addPoint(
					(pointer.X - scr.width  * 0.5) / z, 
					(pointer.Y - scr.height * 0.5) / z, 
					globalZ
				);
				xm = pointer.X;
				ym = pointer.Y;
				// ---- closing shape ----
				currentShape.filled = false;
				currentShape.color = "";
				var first = currentShape.points[0];
				var last  = currentShape.points[currentShape.length - 1];
				var dx = last.x - first.x;
				var dy = last.y - first.y;
				var dz = last.z - first.z;
				var d = Math.sqrt(dx * dx + dy * dy + dz * dz);
				if (d < 15) {
					if (currentShape.length > 4) {
						currentShape.color = 'hsla(' + Math.round(Math.random() * 360) + ', 90%, 60%, 0.2)';
						currentShape.filled = true;
					}
				}
			}
		} else {
			// ---- up ----
			if (currentShape) {
				currentShape = false;
			}
			// ---- rotate ----
			if (auto) {
				var i = 0, s;
				while ( s = shapes[i++]) s.rotate();
			}
		}
	}
	// ==== save drawing ====
	var save = function (id) {
		// ---- clean up ----
		var array = shapes.slice(0);
		for (var i = 0; i < array.length; i++) {
			delete array[i].angle;
			var pts = array[i].points;
			for (var j = 0; j < pts.length; j++) {
				var p = pts[j];
				for (var k in p) {
					if (k.length != 1) delete p[k];
				}
			}
		}
		// ---- save json to local storage ----
		var a = JSON.stringify(array);
		window.localStorage.setItem(id, a);
		// ---- re-load ----
		load(id);
	}
	// ==== load drawing ====
	var load = function (id) {
		// ---- clear all ----
		shapes.length = 0;
		// ---- load ----
		var array = JSON.parse(window.localStorage.getItem(id));
		// ---- rebuild objects ----
		build(array);
	}
	// ==== inject data ====
	var build = function(array) {
		if (array) {
			for (var i = 0; i < array.length; i++) {
				shapes.push(
					currentShape = new Shape()
				);
				var p = array[i].points;
				for (var j = 0; j < p.length; j++) {
					currentShape.points.push(
						new Point(p[j].x, p[j].y, p[j].z)
					);
				}
				currentShape.length = array[i].length;
				currentShape.filled = array[i].filled;
				currentShape.color  = array[i].color;
			}
		}
	}
	// ==== init script ====
	var init = function (json) {
		// ---- screen ----
		scr = new ge1doot.Screen({
			container: "screen",
			resize: function () {
				fov = Math.round(scr.width * 0.5);
			}
		});
		scr.resize();
		ctx = scr.ctx;
		// ---- pointer events ----
		pointer = new ge1doot.Pointer({	});
		// ---- some key events ----
		document.body.onkeydown = function (e) {
			// ---- storage detection ----
			var storage = typeof window.localStorage == 'object';
			// ---- hold/release rotation [SPACE] ----
			if (e.keyCode == 32) {
				auto = !auto;
			}
			// ---- undo shapes [DEL] ----
			if (e.keyCode == 46) {
				if (shapes.length > 0) {
					shapes.length--;
				}
			}
			// ---- switch global Z [Z] ----
			if (e.keyCode == 90) {
				if (globalZ == 0) globalZ = fov * 0.35; else globalZ = 0;
			}
			// ---- save/load [S/L]----
			if (e.keyCode == 83 && storage) save("circumscrible");
			if (e.keyCode == 76 && storage) load("circumscrible");
			return false;
		}

		document.getElementById('clear').onclick = function(){
			currentShape = false;
			start = false;
			shapes.length = 0;
			shapes.push(
				currentShape = new Shape()
			);
		};
		document.getElementById('pause').onclick = function(){
			auto = !auto;
		};

		document.getElementById('back').onclick = function(){
			if (shapes.length > 0) {
					shapes.length--;
			}
		};

		// ---- intro drawing ----
		build(json);
		// ---- engine start ----
		run();
	}
	// ======== main loop ========
	var run = function () {
		ctx.clearRect(0, 0, scr.width, scr.height);
		movePointer();
		// ---- draw shapes ----
		var i = 0, s;
		while ( s = shapes[i++]) {
			s.draw();
		}
		// ---- sparks ----
		ctx.beginPath();
		var i = 0, s;
		while ( s = sparks[i++]) {
			s.draw();
		}
		ctx.lineWidth = 1;
		ctx.strokeStyle = "#00ff88";
		ctx.stroke();
		// ---- animation loop ----
		requestAnimFrame(run);
	}
	
	// ==== Expose captureCanvas function globally ====
	window.captureCanvas = captureCanvas;
	
	return {
		// ---- onload event ----
		load : function (json) {
			window.addEventListener('load', function () {
				init(json);
			}, false);
		}
	}
})().load([
	// P letter
	{"points":[{"x":-200,"y":-100,"z":0},{"x":-200,"y":-80,"z":0},{"x":-200,"y":-60,"z":0},{"x":-200,"y":-40,"z":0},{"x":-200,"y":-20,"z":0},{"x":-200,"y":0,"z":0},{"x":-200,"y":20,"z":0},{"x":-200,"y":40,"z":0},{"x":-200,"y":60,"z":0},{"x":-200,"y":80,"z":0},{"x":-200,"y":100,"z":0}],"length":11,"filled":false,"color":"","fov":640},
	{"points":[{"x":-200,"y":-100,"z":0},{"x":-180,"y":-100,"z":0},{"x":-160,"y":-100,"z":0},{"x":-140,"y":-100,"z":0},{"x":-120,"y":-100,"z":0}],"length":5,"filled":false,"color":"","fov":640},
	{"points":[{"x":-120,"y":-100,"z":0},{"x":-120,"y":-80,"z":0},{"x":-120,"y":-60,"z":0},{"x":-120,"y":-40,"z":0},{"x":-120,"y":-20,"z":0},{"x":-120,"y":0,"z":0}],"length":6,"filled":false,"color":"","fov":640},
	{"points":[{"x":-200,"y":0,"z":0},{"x":-180,"y":0,"z":0},{"x":-160,"y":0,"z":0},{"x":-140,"y":0,"z":0},{"x":-120,"y":0,"z":0}],"length":5,"filled":false,"color":"","fov":640},
	
	// U letter
	{"points":[{"x":-80,"y":-100,"z":0},{"x":-80,"y":-80,"z":0},{"x":-80,"y":-60,"z":0},{"x":-80,"y":-40,"z":0},{"x":-80,"y":-20,"z":0},{"x":-80,"y":0,"z":0},{"x":-80,"y":20,"z":0},{"x":-80,"y":40,"z":0},{"x":-80,"y":60,"z":0},{"x":-80,"y":80,"z":0},{"x":-80,"y":100,"z":0}],"length":11,"filled":false,"color":"","fov":640},
	{"points":[{"x":-80,"y":100,"z":0},{"x":-60,"y":100,"z":0},{"x":-40,"y":100,"z":0},{"x":-20,"y":100,"z":0},{"x":0,"y":100,"z":0}],"length":5,"filled":false,"color":"","fov":640},
	{"points":[{"x":0,"y":100,"z":0},{"x":0,"y":80,"z":0},{"x":0,"y":60,"z":0},{"x":0,"y":40,"z":0},{"x":0,"y":20,"z":0},{"x":0,"y":0,"z":0},{"x":0,"y":-20,"z":0},{"x":0,"y":-40,"z":0},{"x":0,"y":-60,"z":0},{"x":0,"y":-80,"z":0},{"x":0,"y":-100,"z":0}],"length":11,"filled":false,"color":"","fov":640},
	
	// M letter
	{"points":[{"x":40,"y":100,"z":0},{"x":40,"y":80,"z":0},{"x":40,"y":60,"z":0},{"x":40,"y":20,"z":0},{"x":40,"y":0,"z":0},{"x":40,"y":-20,"z":0},{"x":40,"y":-40,"z":0},{"x":40,"y":-60,"z":0},{"x":40,"y":-80,"z":0},{"x":40,"y":-100,"z":0}],"length":10,"filled":false,"color":"","fov":640},
	{"points":[{"x":40,"y":-100,"z":0},{"x":50,"y":-90,"z":0},{"x":60,"y":-80,"z":0},{"x":70,"y":-70,"z":0},{"x":80,"y":-60,"z":0},{"x":90,"y":-50,"z":0},{"x":100,"y":-40,"z":0}],"length":7,"filled":false,"color":"","fov":640},
	{"points":[{"x":100,"y":-40,"z":0},{"x":110,"y":-50,"z":0},{"x":120,"y":-60,"z":0},{"x":130,"y":-70,"z":0},{"x":140,"y":-80,"z":0},{"x":150,"y":-90,"z":0},{"x":160,"y":-100,"z":0}],"length":7,"filled":false,"color":"","fov":640},
	{"points":[{"x":160,"y":-100,"z":0},{"x":160,"y":-80,"z":0},{"x":160,"y":-60,"z":0},{"x":160,"y":-40,"z":0},{"x":160,"y":-20,"z":0},{"x":160,"y":0,"z":0},{"x":160,"y":20,"z":0},{"x":160,"y":40,"z":0},{"x":160,"y":60,"z":0},{"x":160,"y":80,"z":0},{"x":160,"y":100,"z":0}],"length":11,"filled":false,"color":"","fov":640},
	
	// P letter (second)
	{"points":[{"x":200,"y":-100,"z":0},{"x":200,"y":-80,"z":0},{"x":200,"y":-60,"z":0},{"x":200,"y":-40,"z":0},{"x":200,"y":-20,"z":0},{"x":200,"y":0,"z":0},{"x":200,"y":20,"z":0},{"x":200,"y":40,"z":0},{"x":200,"y":60,"z":0},{"x":200,"y":80,"z":0},{"x":200,"y":100,"z":0}],"length":11,"filled":false,"color":"","fov":640},
	{"points":[{"x":200,"y":-100,"z":0},{"x":220,"y":-100,"z":0},{"x":240,"y":-100,"z":0},{"x":260,"y":-100,"z":0},{"x":280,"y":-100,"z":0}],"length":5,"filled":false,"color":"","fov":640},
	{"points":[{"x":280,"y":-100,"z":0},{"x":280,"y":-80,"z":0},{"x":280,"y":-60,"z":0},{"x":280,"y":-40,"z":0},{"x":280,"y":-20,"z":0},{"x":280,"y":0,"z":0}],"length":6,"filled":false,"color":"","fov":640},
	{"points":[{"x":200,"y":0,"z":0},{"x":220,"y":0,"z":0},{"x":240,"y":0,"z":0},{"x":260,"y":0,"z":0},{"x":280,"y":0,"z":0}],"length":5,"filled":false,"color":"","fov":640},
	
	// Pump icon/symbol below text
	{"points":[{"x":-50,"y":150,"z":0},{"x":-30,"y":150,"z":0},{"x":-10,"y":150,"z":0},{"x":10,"y":150,"z":0},{"x":30,"y":150,"z":0},{"x":50,"y":150,"z":0}],"length":6,"filled":false,"color":"","fov":640},
	{"points":[{"x":0,"y":150,"z":0},{"x":0,"y":170,"z":0},{"x":0,"y":190,"z":0},{"x":0,"y":210,"z":0},{"x":0,"y":230,"z":0}],"length":5,"filled":false,"color":"","fov":640},
	{"points":[{"x":-30,"y":230,"z":0},{"x":-20,"y":230,"z":0},{"x":-10,"y":230,"z":0},{"x":0,"y":230,"z":0},{"x":10,"y":230,"z":0},{"x":20,"y":230,"z":0},{"x":30,"y":230,"z":0}],"length":7,"filled":false,"color":"","fov":640},
	{"points":[{"x":-30,"y":230,"z":0},{"x":-30,"y":240,"z":0},{"x":-30,"y":250,"z":0}],"length":3,"filled":false,"color":"","fov":640},
	{"points":[{"x":30,"y":230,"z":0},{"x":30,"y":240,"z":0},{"x":30,"y":250,"z":0}],"length":3,"filled":false,"color":"","fov":640},
	
	// Fun decorative elements (pump.fun style)
	{"points":[{"x":-150,"y":200,"z":50},{"x":-140,"y":190,"z":50},{"x":-130,"y":200,"z":50},{"x":-120,"y":190,"z":50},{"x":-110,"y":200,"z":50}],"length":5,"filled":false,"color":"","fov":640},
	{"points":[{"x":110,"y":200,"z":50},{"x":120,"y":190,"z":50},{"x":130,"y":200,"z":50},{"x":140,"y":190,"z":50},{"x":150,"y":200,"z":50}],"length":5,"filled":false,"color":"","fov":640},
	
	// Additional depth elements
	{"points":[{"x":-100,"y":-150,"z":-50},{"x":-80,"y":-150,"z":-50},{"x":-60,"y":-150,"z":-50},{"x":-40,"y":-150,"z":-50},{"x":-20,"y":-150,"z":-50},{"x":0,"y":-150,"z":-50},{"x":20,"y":-150,"z":-50},{"x":40,"y":-150,"z":-50},{"x":60,"y":-150,"z":-50},{"x":80,"y":-150,"z":-50},{"x":100,"y":-150,"z":-50}],"length":11,"filled":false,"color":"","fov":640},
	{"points":[{"x":-100,"y":300,"z":-50},{"x":-80,"y":300,"z":-50},{"x":-60,"y":300,"z":-50},{"x":-40,"y":300,"z":-50},{"x":-20,"y":300,"z":-50},{"x":0,"y":300,"z":-50},{"x":20,"y":300,"z":-50},{"x":40,"y":300,"z":-50},{"x":60,"y":300,"z":-50},{"x":80,"y":300,"z":-50},{"x":100,"y":300,"z":-50}],"length":11,"filled":false,"color":"","fov":640}
]);

// ==== Token Launch Functionality ====
function openTokenModal() {
	console.log('üöÄ openTokenModal called - starting token launch process');
	try {
		// Capture the current canvas
		console.log('üì∏ Attempting to capture canvas...');
		var imageData = window.captureCanvas();
		console.log('üì∏ Canvas captured:', imageData ? 'SUCCESS' : 'FAILED');
		
		if (!imageData) {
			alert('‚ùå Failed to capture your artwork. Please try drawing something first!');
			return;
		}
		
		// Show the modal
		var modal = document.getElementById('tokenModal');
		if (modal) {
			modal.style.display = 'block';
			console.log('‚úÖ Modal shown successfully');
		} else {
			console.error('‚ùå Modal element not found');
			alert('‚ùå Modal not found. Please refresh the page.');
			return;
		}
		
		// Set the preview image
		var previewImg = document.getElementById('previewImage');
		if (previewImg && imageData) {
			previewImg.src = imageData;
			console.log('‚úÖ Preview image set successfully');
		} else {
			console.error('‚ùå Preview image element not found or no image data');
		}
		
		// Store the image data for later use
		window.currentArtwork = imageData;
		console.log('‚úÖ Artwork stored globally');
		
		// Update wallet UI
		updateWalletUI();
		console.log('‚úÖ Wallet UI updated');
		
		// Setup inputs with delay to ensure DOM is ready
		setTimeout(function() {
			setupInputs();
			console.log('‚úÖ Inputs setup completed');
		}, 100);
		
	} catch (error) {
		console.error('‚ùå Critical error in openTokenModal:', error);
		alert('‚ùå Error opening token modal: ' + error.message);
	}
}

function setupInputs() {
	console.log('üîß Setting up inputs...');
	
	// Generate random token name and ticker
	var randomNames = ['Space Art', 'Neon Dreams', 'Cyber Punk', 'Digital Gold', 'Quantum Wave', 'Retro Pump', 'Matrix Art', 'Future Token'];
	var randomTickers = ['SPCE', 'NEON', 'CYBR', 'DGLD', 'QNTM', 'RTRO', 'MTRX', 'FUTR'];
	
	var randomName = randomNames[Math.floor(Math.random() * randomNames.length)];
	var randomTicker = randomTickers[Math.floor(Math.random() * randomTickers.length)];
	
	var nameInput = document.getElementById('tokenName');
	var tickerInput = document.getElementById('tokenTicker');
	
	if (nameInput) {
		nameInput.value = randomName;
		console.log('‚úÖ Name input auto-filled with:', randomName);
	} else {
		console.error('‚ùå Name input not found');
	}
	
	if (tickerInput) {
		tickerInput.value = randomTicker;
		console.log('‚úÖ Ticker input auto-filled with:', randomTicker);
	} else {
		console.error('‚ùå Ticker input not found');
	}
}

// Simplified button click handler
function handleLaunchButtonClick() {
	console.log('üéØ Launch button clicked!');
	openTokenModal();
}

// Test function to verify button is working
function testButton() {
	console.log('üß™ Testing button functionality...');
	var button = document.getElementById('launchTokenBtn');
	if (button) {
		console.log('‚úÖ Button found:', button);
		console.log('‚úÖ Button visible:', button.offsetWidth > 0 && button.offsetHeight > 0);
		console.log('‚úÖ Button onclick:', button.onclick);
		button.style.backgroundColor = '#ff0000'; // Flash red for visual confirmation
		setTimeout(() => {
			button.style.backgroundColor = '';
		}, 500);
	} else {
		console.error('‚ùå Button not found!');
	}
}

// Enhanced initialization
window.addEventListener('load', function() {
	console.log('üåü Page loaded, initializing...');
	
	// Test button functionality
	setTimeout(() => {
		testButton();
	}, 1000);
	
	// Initialize Solana
	initializeSolana();
	
	// Add multiple event listeners for reliability
	var launchBtn = document.getElementById('launchTokenBtn');
	if (launchBtn) {
		// Remove any existing onclick to avoid conflicts
		launchBtn.onclick = null;
		
		// Add primary click handler
		launchBtn.addEventListener('click', function(e) {
			console.log('üéØ Launch button clicked via event listener');
			e.preventDefault();
			e.stopPropagation();
			handleLaunchButtonClick();
		});
		
		// Add backup onclick handler
		launchBtn.onclick = function(e) {
			console.log('üéØ Launch button clicked via onclick');
			e.preventDefault();
			handleLaunchButtonClick();
		};
		
		console.log('‚úÖ Event listeners added to launch button');
	} else {
		console.error('‚ùå Launch button not found during initialization');
	}
	
	// Add keyboard shortcut for testing
	document.addEventListener('keydown', function(e) {
		if (e.key === 'L' || e.key === 'l') {
			console.log('üéπ Keyboard shortcut pressed - launching modal');
			openTokenModal();
		}
		if (e.key === 'T' || e.key === 't') {
			console.log('üß™ Testing button...');
			testButton();
		}
	});
	
	console.log('üéÆ Keyboard shortcuts added: L = Launch Modal, T = Test Button');
});

// Add window click debugging
window.addEventListener('click', function(e) {
	console.log('üñ±Ô∏è Window clicked:', e.target.tagName, e.target.id, e.target.className);
});

// Test function to verify everything is loaded
function testLaunchButton() {
	console.log('üß™ Testing launch button...');
	console.log('üìã captureCanvas function:', typeof window.captureCanvas);
	console.log('üìã Modal element:', document.getElementById('tokenModal') ? 'FOUND' : 'NOT FOUND');
	console.log('üìã Launch button:', document.querySelector('.launch-token-btn') ? 'FOUND' : 'NOT FOUND');
	console.log('üìã Launch button by ID:', document.getElementById('launchTokenBtn') ? 'FOUND' : 'NOT FOUND');
}

function closeTokenModal() {
	console.log('üîí closeTokenModal called');
	var modal = document.getElementById('tokenModal');
	if (modal) {
		modal.style.display = 'none';
	}
	var statusMsg = document.getElementById('statusMessage');
	if (statusMsg) {
		statusMsg.innerHTML = '';
	}
}

function validateTokenForm() {
	var name = document.getElementById('tokenName').value.trim();
	var ticker = document.getElementById('tokenTicker').value.trim();
	
	if (name.length < 2) {
		showStatus('Token name must be at least 2 characters long', 'error');
		return false;
	}
	
	if (ticker.length < 2 || ticker.length > 10) {
		showStatus('Ticker must be between 2-10 characters', 'error');
		return false;
	}
	
	if (!/^[A-Z0-9]+$/.test(ticker)) {
		showStatus('Ticker must contain only uppercase letters and numbers', 'error');
		return false;
	}
	
	return true;
}

function showStatus(message, type) {
	var statusDiv = document.getElementById('statusMessage');
	if (statusDiv) {
		// Handle multi-line messages
		statusDiv.innerHTML = message.replace(/\n/g, '<br>');
		statusDiv.className = 'status-message status-' + type;
		
		// Auto-scroll to status message
		statusDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
	}
}

async function checkSufficientBalance() {
	try {
		if (!payerKeypair || !walletAddress) {
			console.error('No keypair or wallet address available');
			return false;
		}
		
		console.log('üîç Checking balance for address:', walletAddress);
		
		// Try multiple times in case of network issues
		let balance = 0;
		let attempts = 0;
		const maxAttempts = 3;
		
		while (attempts < maxAttempts) {
			try {
				balance = await connection.getBalance(payerKeypair.publicKey);
				console.log(`üí∞ Balance check attempt ${attempts + 1}: ${balance} lamports`);
				break;
			} catch (balanceError) {
				console.error(`Balance check attempt ${attempts + 1} failed:`, balanceError);
				attempts++;
				if (attempts < maxAttempts) {
					console.log('Retrying balance check...');
					await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
				}
			}
		}
		
		const solBalance = balance / solanaWeb3.LAMPORTS_PER_SOL;
		console.log('üí∞ Final wallet balance:', solBalance, 'SOL');
		
		// Reduced requirement - 0.01 SOL should be enough for pump.fun token
		const requiredSOL = 0.01;
		if (solBalance < requiredSOL) {
			showStatus(`‚ùå Insufficient balance. You have ${solBalance.toFixed(4)} SOL, but need at least ${requiredSOL} SOL for pump.fun token creation.<br><br>` +
				`üîç Checking address: ${walletAddress}<br>` +
				`üí° If you have SOL in this address, try refreshing the page.`, 'error');
			return false;
		}
		
		console.log('‚úÖ Balance check passed:', solBalance, 'SOL');
		return true;
	} catch (error) {
		console.error('Failed to check balance:', error);
		showStatus('Failed to check wallet balance. Please try again. Error: ' + error.message, 'error');
		return false;
	}
}

async function launchToken() {
	console.log('üöÄ launchToken called');
	
	if (!validateTokenForm()) {
		return;
	}
	
	if (!payerKeypair || !walletAddress) {
		showStatus('Private key not initialized. Please refresh the page.', 'error');
		return;
	}
	
	// Check balance
	const hasBalance = await checkSufficientBalance();
	if (!hasBalance) {
		return;
	}
	
	var name = document.getElementById('tokenName').value.trim();
	var ticker = document.getElementById('tokenTicker').value.trim();
	var launchBtn = document.getElementById('launchBtn');
	
	// Disable button and show loading
	if (launchBtn) {
		launchBtn.disabled = true;
		launchBtn.textContent = 'Creating pump.fun Token...';
	}
	
	try {
		showStatus('Preparing your 3D artwork for pump.fun...', 'info');
		
		// Launch token directly with the artwork
		const success = await launchTokenOnPumpFun(name, ticker, window.currentArtwork);
		
		if (success) {
			setTimeout(() => {
				closeTokenModal();
				if (launchBtn) {
					launchBtn.disabled = false;
					launchBtn.textContent = 'üöÄ Create pump.fun Token';
				}
			}, 5000); // Keep modal open longer to show success
		} else {
			if (launchBtn) {
				launchBtn.disabled = false;
				launchBtn.textContent = 'üöÄ Create pump.fun Token';
			}
		}
		
	} catch (error) {
		console.error('Error in launchToken:', error);
		showStatus('Error launching token: ' + error.message, 'error');
		if (launchBtn) {
			launchBtn.disabled = false;
			launchBtn.textContent = 'üöÄ Create pump.fun Token';
		}
	}
}

// Close modal when clicking outside
window.onclick = function(event) {
	var modal = document.getElementById('tokenModal');
	if (event.target == modal) {
		closeTokenModal();
	}
}

// Enhanced token creation with PumpPortal integration
async function launchTokenOnPumpFun(name, symbol, imageUrl) {
	try {
		if (!payerKeypair || !walletAddress) {
			throw new Error('Private key not initialized');
		}

		showStatus('üöÄ Creating REAL pump.fun token with bonding curve...', 'info');
		
		// Use PumpPortal to create real pump.fun token
		return await createPumpPortalToken(name, symbol, imageUrl);
		
	} catch (error) {
		console.error('Pump.fun token creation error:', error);
		showStatus('Failed to create pump.fun token: ' + error.message, 'error');
		return false;
	}
}

// Create real pump.fun token using PumpPortal API
async function createPumpPortalToken(name, symbol, imageUrl) {
	try {
		console.log('üéØ Starting PumpPortal token creation...');
		showStatus('‚ö° Preparing metadata for pump.fun...', 'info');
		
		// Generate new mint keypair for the token
		const mintKeypair = solanaWeb3.Keypair.generate();
		console.log('üè≠ Generated mint address:', mintKeypair.publicKey.toBase58());
		
		// Convert base64 image to blob for upload
		const imageBlob = await dataURLToBlob(imageUrl);
		console.log('üñºÔ∏è Image blob created, size:', imageBlob.size);
		
		// Step 1: Upload metadata to pump.fun IPFS
		showStatus('üì§ Uploading your 3D artwork to IPFS...', 'info');
		
		const formData = new FormData();
		formData.append('file', imageBlob, 'artwork.png');
		formData.append('name', name);
		formData.append('symbol', symbol);
		formData.append('description', `${name} - A unique 3D rotating artwork created with 3D Drawing Studio. Now on pump.fun with bonding curve!`);
		formData.append('website', 'https://pump.fun');
		formData.append('showName', 'true');
		
		console.log('üì§ Uploading to pump.fun IPFS...');
		
		let metadataResponse;
		try {
			metadataResponse = await fetch('https://pump.fun/api/ipfs', {
				method: 'POST',
				mode: 'cors',
				body: formData
			});
		} catch (corsError) {
			console.error('CORS error with pump.fun IPFS:', corsError);
			throw new Error('pump.fun APIs are not accessible from this domain. This is expected on localhost due to CORS restrictions.');
		}
		
		if (!metadataResponse.ok) {
			throw new Error(`IPFS upload failed: ${metadataResponse.status} ${metadataResponse.statusText}`);
		}
		
		const metadataResponseJSON = await metadataResponse.json();
		console.log('‚úÖ IPFS upload successful:', metadataResponseJSON);
		
		if (!metadataResponseJSON.metadataUri) {
			throw new Error('No metadata URI returned from IPFS upload');
		}
		
		// Step 2: Generate pump.fun transaction using PumpPortal
		showStatus('‚ö° Building pump.fun transaction with bonding curve...', 'info');
		
		const tokenMetadata = {
			name: name,
			symbol: symbol,
			uri: metadataResponseJSON.metadataUri
		};
		
		console.log('üèóÔ∏è Requesting transaction from PumpPortal...');
		
		let tradeResponse;
		try {
			tradeResponse = await fetch('https://pumpportal.fun/api/trade-local', {
				method: 'POST',
				mode: 'cors',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify({
					publicKey: payerKeypair.publicKey.toBase58(),
					action: 'create',
					tokenMetadata: tokenMetadata,
					mint: mintKeypair.publicKey.toBase58(),
					denominatedInSol: 'true',
					amount: 0.01, // Initial dev buy of 0.01 SOL
					slippage: 10,
					priorityFee: 0.0005,
					pool: 'pump'
				})
			});
		} catch (corsError) {
			console.error('CORS error with PumpPortal:', corsError);
			throw new Error('PumpPortal API is not accessible from this domain. This is expected on localhost due to CORS restrictions.');
		}
		
		if (!tradeResponse.ok) {
			const errorText = await tradeResponse.text();
			throw new Error(`PumpPortal transaction generation failed: ${tradeResponse.status} - ${errorText}`);
		}
		
		console.log('‚úÖ Transaction received from PumpPortal');
		
		// Step 3: Sign and send the transaction
		showStatus('‚úçÔ∏è Signing pump.fun transaction...', 'info');
		
		const transactionBase64 = await tradeResponse.text();
		console.log('üì¶ Transaction data received, length:', transactionBase64.length);
		
		// Decode the versioned transaction
		const transactionBuffer = Uint8Array.from(atob(transactionBase64), c => c.charCodeAt(0));
		const versionedTransaction = solanaWeb3.VersionedTransaction.deserialize(transactionBuffer);
		
		console.log('üîì Transaction deserialized successfully');
		
		// Sign with both mint keypair and payer keypair
		versionedTransaction.sign([mintKeypair, payerKeypair]);
		console.log('‚úÖ Transaction signed with both keypairs');
		
		showStatus('üöÄ Sending pump.fun token to blockchain...', 'info');
		
		// Send the signed transaction
		const signature = await connection.sendRawTransaction(versionedTransaction.serialize(), {
			skipPreflight: false,
			preflightCommitment: 'processed'
		});
		
		console.log('üìù Transaction sent, signature:', signature);
		
		showStatus('‚è≥ Confirming pump.fun token creation...', 'info');
		
		// Wait for confirmation
		const confirmation = await connection.confirmTransaction({
			signature: signature,
			blockhash: (await connection.getLatestBlockhash()).blockhash,
			lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight
		}, 'confirmed');
		
		if (confirmation.value.err) {
			throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));
		}
		
		// Success!
		const mintAddress = mintKeypair.publicKey.toBase58();
		
		showStatus(`üéâ PUMP.FUN TOKEN CREATED SUCCESSFULLY!<br><br>` +
			`üöÄ <strong>${name} (${symbol})</strong><br>` +
			`‚úÖ Mint Address: <a href="https://pump.fun/${mintAddress}" target="_blank" style="color: #00ff88; text-decoration: underline;">${mintAddress}</a><br>` +
			`‚úÖ Transaction: <a href="https://solscan.io/tx/${signature}" target="_blank" style="color: #00ff88; text-decoration: underline;">${signature.slice(0, 8)}...${signature.slice(-8)}</a><br>` +
			`‚úÖ IPFS Metadata: <a href="${metadataResponseJSON.metadataUri}" target="_blank" style="color: #00ff88; text-decoration: underline;">View Metadata</a><br><br>` +
			`üî• <strong>Your token is now LIVE on pump.fun!</strong><br>` +
			`üí∞ <a href="https://pump.fun/${mintAddress}" target="_blank" style="color: #00ff88; text-decoration: underline; font-weight: bold;">Trade Now on pump.fun ‚Üí</a><br>` +
			`üìä Your token has a bonding curve and is ready for trading!<br>` +
			`üé® Your 3D artwork is the official token image!<br>` +
			`üíé Initial dev buy: 0.01 SOL`, 'success');
		
		console.log('‚úÖ Pump.fun token created successfully:', mintAddress);
		return true;
		
	} catch (error) {
		console.error('‚ùå PumpPortal token creation failed:', error);
		
		// Provide specific error messages
		if (error.message.includes('IPFS upload failed')) {
			showStatus('‚ùå Failed to upload artwork to IPFS. Please try again.', 'error');
		} else if (error.message.includes('PumpPortal transaction generation failed')) {
			showStatus('‚ùå Failed to generate pump.fun transaction. Please check your balance and try again.', 'error');
		} else if (error.message.includes('insufficient')) {
			showStatus('‚ùå Insufficient SOL balance. You need at least 0.15 SOL for pump.fun token creation (0.01 SOL dev buy + fees).', 'error');
		} else if (error.message.includes('blockhash')) {
			showStatus('‚ùå Network issue. Please try again in a moment.', 'error');
		} else {
			showStatus('‚ùå Failed to create pump.fun token: ' + error.message, 'error');
		}
		
		return false;
	}
}

// Helper function to convert data URL to Blob
async function dataURLToBlob(dataURL) {
	try {
		const response = await fetch(dataURL);
		return await response.blob();
	} catch (error) {
		console.error('Failed to convert data URL to blob:', error);
		throw new Error('Failed to process artwork image');
	}
}

// Simplified token creation that works reliably
async function createSimplifiedToken(name, symbol, imageUrl) {
	// This function is now replaced by PumpPortal implementation
	return await createPumpPortalToken(name, symbol, imageUrl);
}

// Helper function to create initialize mint instruction
function createInitializeMintInstruction(mint, decimals, mintAuthority, freezeAuthority) {
	const keys = [
		{ pubkey: mint, isSigner: false, isWritable: true },
		{ pubkey: new solanaWeb3.PublicKey('SysvarRent111111111111111111111111111111111'), isSigner: false, isWritable: false }
	];
	
	// Instruction data: [instruction_type(1), decimals(1), mint_authority(32), option(1), freeze_authority(32)]
	const data = new Uint8Array(67);
	data[0] = 0; // InitializeMint instruction
	data[1] = decimals;
	
	// Copy mint authority (32 bytes)
	const mintAuthorityBytes = mintAuthority.toBytes();
	data.set(mintAuthorityBytes, 2);
	
	// Option byte for freeze authority (1 = Some, 0 = None)
	data[34] = freezeAuthority ? 1 : 0;
	
	// Copy freeze authority if provided (32 bytes)
	if (freezeAuthority) {
		const freezeAuthorityBytes = freezeAuthority.toBytes();
		data.set(freezeAuthorityBytes, 35);
	}
	
	return new solanaWeb3.TransactionInstruction({
		keys,
		programId: new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),
		data
	});
}

// Create real pump.fun token with bonding curve
async function createRealPumpFunToken(name, symbol, imageUrl) {
	// This function is now replaced by the PumpPortal implementation above
	return await createPumpPortalToken(name, symbol, imageUrl);
}
</script>
</head>
<body>
<canvas id="screen">Your browser doesn't support HTML5 canvas technology. Please use Google Chrome.</canvas>

<!-- Launch Token Button -->
<button class="launch-token-btn" onclick="handleLaunchButtonClick()" id="launchTokenBtn">üöÄ Create pump.fun Token</button>

<!-- Token Launch Modal -->
<div id="tokenModal" class="modal">
	<div class="modal-content">
		<span class="close" onclick="closeTokenModal()">&times;</span>
		<h2>üöÄ Launch Your Token on Pump.fun</h2>
		
		<div class="preview-container">
			<img id="previewImage" class="preview-image" alt="Your 3D Artwork" />
		</div>
		
		<!-- Wallet Connection Section -->
		<div class="wallet-section">
			<div class="wallet-status">
				<div>
					<strong>Phantom Wallet:</strong> <span id="walletStatus">Not Connected</span>
				</div>
				<button id="connectWalletBtn" class="connect-wallet-btn" onclick="connectWallet()">
					Connect Phantom
				</button>
			</div>
			<div id="walletAddress" class="wallet-address"></div>
		</div>
		
		<div style="margin: 20px 0;">
			<label style="display: block; color: #fff; margin-bottom: 8px; font-weight: 500;">Token Name:</label>
			<input 
				type="text" 
				id="tokenName" 
				placeholder="Enter token name"
				style="width: 100%; padding: 12px; border: 2px solid #444; border-radius: 10px; background: #2a1f3d; color: #fff; font-size: 16px; box-sizing: border-box; outline: none;"
			/>
		</div>
		
		<div style="margin: 20px 0;">
			<label style="display: block; color: #fff; margin-bottom: 8px; font-weight: 500;">Ticker Symbol:</label>
			<input 
				type="text" 
				id="tokenTicker" 
				placeholder="Enter ticker"
				style="width: 100%; padding: 12px; border: 2px solid #444; border-radius: 10px; background: #2a1f3d; color: #fff; font-size: 16px; box-sizing: border-box; outline: none;"
			/>
		</div>
		
		<div id="statusMessage"></div>
		
		<button id="launchBtn" class="launch-btn" onclick="launchToken()" disabled>
			üöÄ Create pump.fun Token
		</button>
		
		<div style="margin-top: 15px; text-align: center; color: #aaa; font-size: 12px;">
			Your 3D artwork will be used as the token image.<br>
			Description will be left empty as requested.<br>
			<strong>Phantom wallet will sign the transaction securely.</strong>
		</div>
	</div>
</div>

<!-- dhteumeuleu nav menu -->
<div id="nav">
	<input type="checkbox" name="nav-switch" id="nav-switch">
	<label class="label" for="nav-switch">
		<div class="container">
			<div class="nav-on">
				<ul class="menu">
					<li class="home"><a target="_top" href="/">Home</a></li>
					<li class="list"><a id='clear' href="javascript:void();">Clear</a></li>
					<li class="arrow back"><a id='pause' href="javascript:void();">Pause</a></li>
					<li class="arrow"><a id='back' href="javascript:void();">Undo</a></li>				</ul>
			</div>
			<div class="nav-off">
				<div id="icon"><div></div><div></div></div>
				<h1 class="title">What would your name look like in 3D?<br>Draw it and find out!</h1>
			</div>
		</div>
	</label>
</div> 
<!-- end of dhteumeuleu nav menu -->

</body>
</html>